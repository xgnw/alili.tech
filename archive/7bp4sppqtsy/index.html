<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="$HTML， HTTP，web 综合问题 常见排序算法的时间复杂度,空间复杂度 前端需要注意哪些 SEO  合理的 title、description、keywords：搜索对着三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超过 2 次，而且要靠前，不同页面 title 要有所不同；description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面 descri"><meta name="keywords" content="前端面试, 知识点, 前端知识点, 前端"><meta property="og:locale" content="en_US"><meta property="og:title" content="前端面试知识点收集 - 综合篇"><meta property="og:image" content="https://alili.tech/images/logo.png"><meta property="og:description" content="$HTML， HTTP，web 综合问题 常见排序算法的时间复杂度,空间复杂度 前端需要注意哪些 SEO  合理的 title、description、keywords：搜索对着三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超过 2 次，而且要靠前，不同页面 title 要有所不同；description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面 descri"><meta property="og:site_name" content="Hello Alili"><title>前端面试知识点收集 - 综合篇 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet"><link href="https://cdn.bootcdn.net/ajax/libs/justifiedGallery/3.6.1/css/justifiedGallery.min.css" rel="stylesheet"><link rel="preload" href="https://alili.tech/css/style.css" as="style"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://cdn.bootcdn.net/ajax/libs/jquery/2.1.3/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/hvvo3rmt3dj/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/xabyh5mwmo/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f7bp4sppqtsy%2f&text=%e5%89%8d%e7%ab%af%e9%9d%a2%e8%af%95%e7%9f%a5%e8%af%86%e7%82%b9%e6%94%b6%e9%9b%86%20-%20%e7%bb%bc%e5%90%88%e7%af%87"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f7bp4sppqtsy%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f7bp4sppqtsy%2f&text=%e5%89%8d%e7%ab%af%e9%9d%a2%e8%af%95%e7%9f%a5%e8%af%86%e7%82%b9%e6%94%b6%e9%9b%86%20-%20%e7%bb%bc%e5%90%88%e7%af%87"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f7bp4sppqtsy%2f&title=%e5%89%8d%e7%ab%af%e9%9d%a2%e8%af%95%e7%9f%a5%e8%af%86%e7%82%b9%e6%94%b6%e9%9b%86%20-%20%e7%bb%bc%e5%90%88%e7%af%87"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f7bp4sppqtsy%2f&is_video=false&description=%e5%89%8d%e7%ab%af%e9%9d%a2%e8%af%95%e7%9f%a5%e8%af%86%e7%82%b9%e6%94%b6%e9%9b%86%20-%20%e7%bb%bc%e5%90%88%e7%af%87"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e5%89%8d%e7%ab%af%e9%9d%a2%e8%af%95%e7%9f%a5%e8%af%86%e7%82%b9%e6%94%b6%e9%9b%86%20-%20%e7%bb%bc%e5%90%88%e7%af%87&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f7bp4sppqtsy%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f7bp4sppqtsy%2f&title=%e5%89%8d%e7%ab%af%e9%9d%a2%e8%af%95%e7%9f%a5%e8%af%86%e7%82%b9%e6%94%b6%e9%9b%86%20-%20%e7%bb%bc%e5%90%88%e7%af%87"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f7bp4sppqtsy%2f&title=%e5%89%8d%e7%ab%af%e9%9d%a2%e8%af%95%e7%9f%a5%e8%af%86%e7%82%b9%e6%94%b6%e9%9b%86%20-%20%e7%bb%bc%e5%90%88%e7%af%87"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f7bp4sppqtsy%2f&title=%e5%89%8d%e7%ab%af%e9%9d%a2%e8%af%95%e7%9f%a5%e8%af%86%e7%82%b9%e6%94%b6%e9%9b%86%20-%20%e7%bb%bc%e5%90%88%e7%af%87"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f7bp4sppqtsy%2f&title=%e5%89%8d%e7%ab%af%e9%9d%a2%e8%af%95%e7%9f%a5%e8%af%86%e7%82%b9%e6%94%b6%e9%9b%86%20-%20%e7%bb%bc%e5%90%88%e7%af%87"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><ul><li><a href="#html-http-web-综合问题">$HTML， HTTP，web 综合问题</a><ul><li><a href="#常见排序算法的时间复杂度-空间复杂度">常见排序算法的时间复杂度,空间复杂度</a></li><li><a href="#前端需要注意哪些-seo">前端需要注意哪些 SEO</a></li><li><a href="#web-开发中会话跟踪的方法有哪些">web 开发中会话跟踪的方法有哪些</a></li><li><a href="#img-的-title-和-alt-有什么区别"><code>&lt;img&gt;</code>的<code>title</code>和<code>alt</code>有什么区别</a></li><li><a href="#doctype-是什么-举例常见-doctype-及特点">doctype 是什么,举例常见 doctype 及特点</a></li><li><a href="#html-全局属性-global-attribute-有哪些">HTML 全局属性(global attribute)有哪些</a></li><li><a href="#什么是-web-语义化-有什么好处">什么是 web 语义化,有什么好处</a></li><li><a href="#http-method">HTTP method</a></li><li><a href="#从浏览器地址栏输入-url-到显示页面的步骤-以-http-为例">从浏览器地址栏输入 url 到显示页面的步骤(以 HTTP 为例)</a></li><li><a href="#http-request-报文结构是怎样的">HTTP request 报文结构是怎样的</a></li><li><a href="#http-response-报文结构是怎样的">HTTP response 报文结构是怎样的</a></li><li><a href="#如何进行网站性能优化">如何进行网站性能优化</a></li><li><a href="#什么是渐进增强">什么是渐进增强</a></li><li><a href="#http-状态码及其含义">HTTP 状态码及其含义</a></li></ul></li><li><a href="#css-部分">$CSS 部分</a><ul><li><a href="#css-选择器有哪些">CSS 选择器有哪些</a></li><li><a href="#css-sprite-是什么-有什么优缺点">css sprite 是什么,有什么优缺点</a></li><li><a href="#display-none-与-visibility-hidden-的区别"><code>display: none;</code>与<code>visibility: hidden;</code>的区别</a></li><li><a href="#css-hack-原理及常用-hack">css hack 原理及常用 hack</a></li><li><a href="#specified-value-computed-value-used-value-计算方法">specified value,computed value,used value 计算方法</a></li><li><a href="#link-与-import-的区别"><code>link</code>与<code>@import</code>的区别</a></li><li><a href="#display-block-和-display-inline-的区别"><code>display: block;</code>和<code>display: inline;</code>的区别</a></li><li><a href="#png-gif-jpg-的区别及如何选">PNG,GIF,JPG 的区别及如何选</a></li><li><a href="#css-有哪些继承属性">CSS 有哪些继承属性</a></li><li><a href="#ie6-浏览器有哪些常见的-bug-缺陷或者与标准不一致的地方-如何解决">IE6 浏览器有哪些常见的 bug,缺陷或者与标准不一致的地方,如何解决</a></li><li><a href="#容器包含若干浮动元素时如何清理-包含-浮动">容器包含若干浮动元素时如何清理(包含)浮动</a></li><li><a href="#什么是-fouc-如何避免">什么是 FOUC?如何避免</a></li><li><a href="#如何创建块级格式化上下文-block-formatting-context-bfc-有什么用">如何创建块级格式化上下文(block formatting context),BFC 有什么用</a></li><li><a href="#display-float-position-的关系">display,float,position 的关系</a></li><li><a href="#外边距折叠-collapsing-margins">外边距折叠(collapsing margins)</a></li><li><a href="#如何确定一个元素的包含块-containing-block">如何确定一个元素的包含块(containing block)</a></li><li><a href="#stacking-context-布局规则">stacking context,布局规则</a></li><li><a href="#如何水平居中一个元素">如何水平居中一个元素</a></li><li><a href="#如何竖直居中一个元素">如何竖直居中一个元素</a></li></ul></li><li><a href="#javascript-概念部分">$javascript 概念部分</a><ul><li><a href="#dom-元素-e-的-e-getattribute-propname-和-e-propname-有什么区别和联系">DOM 元素 e 的 e.getAttribute(propName)和 e.propName 有什么区别和联系</a></li><li><a href="#offsetwidth-offsetheight-clientwidth-clientheight-与-scrollwidth-scrollheight-的区别">offsetWidth/offsetHeight,clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别</a></li><li><a href="#xmlhttprequest-通用属性和方法">XMLHttpRequest 通用属性和方法</a></li><li><a href="#focus-blur-与-focusin-focusout-的区别与联系">focus/blur 与 focusin/focusout 的区别与联系</a></li><li><a href="#mouseover-mouseout-与-mouseenter-mouseleave-的区别与联系">mouseover/mouseout 与 mouseenter/mouseleave 的区别与联系</a></li><li><a href="#sessionstorage-localstorage-cookie-区别">sessionStorage,localStorage,cookie 区别</a></li><li><a href="#javascript-跨域通信">javascript 跨域通信</a></li><li><a href="#javascript-有哪几种数据类型">javascript 有哪几种数据类型</a></li><li><a href="#什么闭包-闭包有什么用">什么闭包,闭包有什么用</a></li><li><a href="#javascript-有哪几种方法定义函数">javascript 有哪几种方法定义函数</a></li><li><a href="#应用程序存储和离线-web-应用">应用程序存储和离线 web 应用</a></li><li><a href="#客户端存储-localstorage-和-sessionstorage">客户端存储 localStorage 和 sessionStorage</a></li><li><a href="#cookie-及其操作">cookie 及其操作</a></li><li><a href="#javascript-有哪些方法定义对象">javascript 有哪些方法定义对象</a></li><li><a href="#运算符判断相等的流程是怎样的">===运算符判断相等的流程是怎样的</a></li><li><a href="#运算符判断相等的流程是怎样的-1">==运算符判断相等的流程是怎样的</a></li><li><a href="#对象到字符串的转换步骤">对象到字符串的转换步骤</a></li><li><a href="#对象到数字的转换步骤">对象到数字的转换步骤</a></li><li><a href="#的比较规则">&lt;,&gt;,&lt;=,&gt;=的比较规则</a></li><li><a href="#运算符工作流程">+运算符工作流程</a></li><li><a href="#函数内部-arguments-变量有哪些特性-有哪些属性-如何将它转换为数组">函数内部 arguments 变量有哪些特性,有哪些属性,如何将它转换为数组</a></li><li><a href="#dom-事件模型是如何的-编写一个-eventutil-工具类实现事件管理兼容">DOM 事件模型是如何的,编写一个 EventUtil 工具类实现事件管理兼容</a></li><li><a href="#评价一下三种方法实现继承的优缺点-并改进">评价一下三种方法实现继承的优缺点,并改进</a></li></ul></li><li><a href="#javascript-编程部分">$javascript 编程部分</a><ul><li><a href="#请用原生-js-实现一个函数-给页面制定的任意一个元素添加一个透明遮罩-透明度可变-默认-0-2-使这个区域点击无效-要求兼容-ie8-及各主流浏览器-遮罩层效果如下图所示">请用原生 js 实现一个函数,给页面制定的任意一个元素添加一个透明遮罩(透明度可变,默认 0.2),使这个区域点击无效,要求兼容 IE8+及各主流浏览器,遮罩层效果如下图所示:</a></li><li><a href="#请用代码写出-今天是星期-x-其中-x-表示当天是星期几-如果当天是星期一-输出应该是-今天是星期一">请用代码写出(今天是星期 x)其中 x 表示当天是星期几,如果当天是星期一,输出应该是&rdquo;今天是星期一&rdquo;</a></li><li><a href="#下面这段代码想要循环延时输出结果-0-1-2-3-4-请问输出结果是否正确-如果不正确-请说明为什么-并修改循环内的代码使其输出正确结果">下面这段代码想要循环延时输出结果 0 1 2 3 4,请问输出结果是否正确,如果不正确,请说明为什么,并修改循环内的代码使其输出正确结果</a></li><li><a href="#现有一个-page-类-其原型对象上有许多以-post-开头的方法-如-postmsg-另有一拦截函数-chekc-只返回-ture-或-false-请设计一个函数-该函数应批量改造原-page-的-postxxx-方法-在保留其原有功能的同时-为每个-postxxx-方法增加拦截验证功能-当-chekc-返回-true-时继续执行原-postxxx-方法-返回-false-时不再执行原-postxxx-方法">现有一个 Page 类,其原型对象上有许多以 post 开头的方法(如 postMsg);另有一拦截函数 chekc,只返回 ture 或 false.请设计一个函数,该函数应批量改造原 Page 的 postXXX 方法,在保留其原有功能的同时,为每个 postXXX 方法增加拦截验证功能,当 chekc 返回 true 时继续执行原 postXXX 方法,返回 false 时不再执行原 postXXX 方法</a></li><li><a href="#完成下面的-tool-tip">完成下面的 tool-tip</a></li><li><a href="#编写-javascript-深度克隆函数-deepclone">编写 javascript 深度克隆函数 deepClone</a></li><li><a href="#补充代码-鼠标单击-button1-后将-button1-移动到-button2-的后面">补充代码,鼠标单击 Button1 后将 Button1 移动到 Button2 的后面</a></li><li><a href="#网页中实现一个计算当年还剩多少时间的倒数计时程序-要求网页上实时动态显示-年还剩-天-时-分-秒">网页中实现一个计算当年还剩多少时间的倒数计时程序,要求网页上实时动态显示&rdquo;×× 年还剩 ×× 天 ×× 时 ×× 分 ×× 秒&rdquo;</a></li><li><a href="#完成一个函数-接受数组作为参数-数组元素为整数或者数组-数组元素包含整数或数组-函数返回扁平化后的数组">完成一个函数,接受数组作为参数,数组元素为整数或者数组,数组元素包含整数或数组,函数返回扁平化后的数组</a></li><li><a href="#如何判断一个对象是否为数组">如何判断一个对象是否为数组</a></li><li><a href="#请评价以下事件监听器代码并给出改进意见">请评价以下事件监听器代码并给出改进意见</a></li><li><a href="#如何判断一个对象是否为函数">如何判断一个对象是否为函数</a></li><li><a href="#编写一个函数接受-url-中-query-string-为参数-返回解析后的-object-query-string-使用-application-x-www-form-urlencoded-编码">编写一个函数接受 url 中 query string 为参数,返回解析后的 Object,query string 使用 application/x-www-form-urlencoded 编码</a></li><li><a href="#解析一个完整的-url-返回-object-包含域与-window-location-相同">解析一个完整的 url,返回 Object 包含域与 window.location 相同</a></li><li><a href="#完成函数-getviewportsize-返回指定窗口的视口尺寸">完成函数 getViewportSize 返回指定窗口的视口尺寸</a></li><li><a href="#完成函数-getscrolloffset-返回窗口滚动条偏移量">完成函数 getScrollOffset 返回窗口滚动条偏移量</a></li><li><a href="#现有一个字符串-richtext-是一段富文本-需要显示在页面上-有个要求-需要给其中只包含一个-img-元素的-p-标签增加一个叫-pic-的-class-请编写代码实现-可以使用-jquery-或-kissy">现有一个字符串 richText,是一段富文本,需要显示在页面上.有个要求,需要给其中只包含一个 img 元素的 p 标签增加一个叫 pic 的 class.请编写代码实现.可以使用 jQuery 或 KISSY.</a></li><li><a href="#请实现一个-event-类-继承自此类的对象都会拥有两个方法-on-off-once-和-trigger">请实现一个 Event 类,继承自此类的对象都会拥有两个方法 on,off,once 和 trigger</a></li><li><a href="#编写一个函数将列表子元素顺序反转">编写一个函数将列表子元素顺序反转</a></li><li><a href="#以下函数的作用是-空白区域应该填写什么">以下函数的作用是?空白区域应该填写什么</a></li><li><a href="#编写一个函数实现-form-的序列化-即将一个表单中的键值序列化为可提交的字符串">编写一个函数实现 form 的序列化(即将一个表单中的键值序列化为可提交的字符串)</a></li><li><a href="#使用原生-javascript-给下面列表中的-li-节点绑定点击事件-点击时创建一个-object-对象-兼容-ie-和标准浏览器">使用原生 javascript 给下面列表中的 li 节点绑定点击事件,点击时创建一个 Object 对象,兼容 IE 和标准浏览器</a></li><li><a href="#有一个大数组-var-a-1-2-3-a-的长度是-100-内容填充随机整数的字符串-请先构造此数组-a-然后设计一个算法将其内容去重">有一个大数组,var a = [&lsquo;1&rsquo;, &lsquo;2&rsquo;, &lsquo;3&rsquo;, &hellip;];a 的长度是 100,内容填充随机整数的字符串.请先构造此数组 a,然后设计一个算法将其内容去重</a></li></ul></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">前端面试知识点收集 - 综合篇</h1><div class="meta"><div class="postdate"><time datetime="2019-01-04" itemprop="datePublished">2019-01-04</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag"><i class="fa fa-tag"></i> <a href="/tags/interview">Interview</a></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><h2 id="html-http-web-综合问题">$HTML， HTTP，web 综合问题</h2><h3 id="常见排序算法的时间复杂度-空间复杂度">常见排序算法的时间复杂度,空间复杂度</h3><p><img src="img/sort-compare.png" alt="排序算法比较"></p><h3 id="前端需要注意哪些-seo">前端需要注意哪些 SEO</h3><ol><li>合理的 title、description、keywords：搜索对着三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超过 2 次，而且要靠前，不同页面 title 要有所不同；description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面 description 有所不同；keywords 列举出重要关键词即可</li><li>语义化的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页</li><li>重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取</li><li>重要内容不要用 js 输出：爬虫不会执行 js 获取内容</li><li>少用 iframe：搜索引擎不会抓取 iframe 中的内容</li><li>非装饰性图片必须加 alt</li><li>提高网站速度：网站速度是搜索引擎排序的一个重要指标</li></ol><h3 id="web-开发中会话跟踪的方法有哪些">web 开发中会话跟踪的方法有哪些</h3><ol><li>cookie</li><li>session</li><li>url 重写</li><li>隐藏 input</li><li>ip 地址</li></ol><h3 id="img-的-title-和-alt-有什么区别"><code>&lt;img&gt;</code>的<code>title</code>和<code>alt</code>有什么区别</h3><ol><li><code>title</code>是<a href="http://www.w3.org/TR/html-markup/global-attributes.html#common.attrs.core">global attributes</a>之一，用于为元素提供附加的 advisory information。通常当鼠标滑动到元素上的时候显示。</li><li><code>alt</code>是<code>&lt;img&gt;</code>的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。</li></ol><h3 id="doctype-是什么-举例常见-doctype-及特点">doctype 是什么,举例常见 doctype 及特点</h3><ol><li><code>&lt;!doctype&gt;</code>声明必须处于 HTML 文档的头部，在<code>&lt;html&gt;</code>标签之前，HTML5 中不区分大小写</li><li><code>&lt;!doctype&gt;</code>声明不是一个 HTML 标签，是一个用于告诉浏览器当前 HTMl 版本的指令</li><li>现代浏览器的 html 布局引擎通过检查 doctype 决定使用兼容模式还是标准模式对文档进行渲染，一些浏览器有一个接近标准模型。</li><li>在 HTML4.01 中<code>&lt;!doctype&gt;</code>声明指向一个 DTD，由于 HTML4.01 基于 SGML，所以 DTD 指定了标记规则以保证浏览器正确渲染内容</li><li>HTML5 不基于 SGML，所以不用指定 DTD</li></ol><p>常见 dotype：</p><ol><li><strong>HTML4.01 strict</strong>：不允许使用表现性、废弃元素（如 font）以及 frameset。声明：<code>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;</code></li><li><strong>HTML4.01 Transitional</strong>:允许使用表现性、废弃元素（如 font），不允许使用 frameset。声明：<code>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</code></li><li><strong>HTML4.01 Frameset</strong>:允许表现性元素，废气元素以及 frameset。声明：<code>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot; &quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&gt;</code></li><li><strong>XHTML1.0 Strict</strong>:不使用允许表现性、废弃元素以及 frameset。文档必须是结构良好的 XML 文档。声明：<code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;</code></li><li><strong>XHTML1.0 Transitional</strong>:允许使用表现性、废弃元素，不允许 frameset，文档必须是结构良好的 XMl 文档。声明： <code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</code></li><li><strong>XHTML 1.0 Frameset</strong>:允许使用表现性、废弃元素以及 frameset，文档必须是结构良好的 XML 文档。声明：<code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Frameset//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt;</code></li><li><strong>HTML 5</strong>: <code>&lt;!doctype html&gt;</code></li></ol><h3 id="html-全局属性-global-attribute-有哪些">HTML 全局属性(global attribute)有哪些</h3><p>参考资料：<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes">MDN: html global attribute</a>或者<a href="http://www.w3.org/TR/html-markup/global-attributes.html#common.attrs.core">W3C HTML global-attributes</a></p><ul><li><code>accesskey</code>:设置快捷键，提供快速访问元素如<a href="#" accesskey="a">aaa</a>在 windows 下的 firefox 中按<code>alt + shift + a</code>可激活元素</li><li><code>class</code>:为元素设置类标识，多个类名用空格分开，CSS 和 javascript 可通过 class 属性获取元素</li><li><code>contenteditable</code>: 指定元素内容是否可编辑</li><li><code>contextmenu</code>: 自定义鼠标右键弹出菜单内容</li><li><code>data-*</code>: 为元素增加自定义属性</li><li><code>dir</code>: 设置元素文本方向</li><li><code>draggable</code>: 设置元素是否可拖拽</li><li><code>dropzone</code>: 设置元素拖放类型： copy, move, link</li><li><code>hidden</code>: 表示一个元素是否与文档。样式上会导致元素不显示，但是不能用这个属性实现样式效果</li><li><code>id</code>: 元素 id，文档内唯一</li><li><code>lang</code>: 元素内容的的语言</li><li><code>spellcheck</code>: 是否启动拼写和语法检查</li><li><code>style</code>: 行内 css 样式</li><li><code>tabindex</code>: 设置元素可以获得焦点，通过 tab 可以导航</li><li><code>title</code>: 元素相关的建议信息</li><li><code>translate</code>: 元素和子孙节点内容是否需要本地化</li></ul><h3 id="什么是-web-语义化-有什么好处">什么是 web 语义化,有什么好处</h3><p>web 语义化是指通过 HTML 标记表示页面包含的信息，包含了 HTML 标签的语义化和 css 命名的语义化。 HTML 标签的语义化是指：通过使用包含语义的标签（如 h1-h6）恰当地表示文档结构 css 命名的语义化是指：为 html 标签添加有意义的 class，id 补充未表达的语义，如<a href="http://en.wikipedia.org/wiki/Microformats">Microformat</a>通过添加符合规则的 class 描述信息 为什么需要语义化：</p><ul><li>去掉样式后页面呈现清晰的结构</li><li>盲人使用读屏器更好地阅读</li><li>搜索引擎更好地理解页面，有利于收录</li><li>便团队项目的可持续运作及维护</li></ul><h3 id="http-method">HTTP method</h3><ol><li>一台服务器要与 HTTP1.1 兼容，只要为资源实现<strong>GET</strong>和<strong>HEAD</strong>方法即可</li><li><strong>GET</strong>是最常用的方法，通常用于<strong>请求服务器发送某个资源</strong>。</li><li><strong>HEAD</strong>与 GET 类似，但<strong>服务器在响应中值返回首部，不返回实体的主体部分</strong></li><li><strong>PUT</strong>让服务器<strong>用请求的主体部分来创建一个由所请求的 URL 命名的新文档，或者，如果那个 URL 已经存在的话，就用干这个主体替代它</strong></li><li><strong>POST</strong>起初是用来向服务器输入数据的。实际上，通常会用它来支持 HTML 的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到要去的地方。</li><li><strong>TRACE</strong>会在目的服务器端发起一个环回诊断，最后一站的服务器会弹回一个 TRACE 响应并在响应主体中携带它收到的原始请求报文。TRACE 方法主要用于诊断，用于验证请求是否如愿穿过了请求/响应链。</li><li><strong>OPTIONS</strong>方法请求 web 服务器告知其支持的各种功能。可以查询服务器支持哪些方法或者对某些特殊资源支持哪些方法。</li><li><strong>DELETE</strong>请求服务器删除请求 URL 指定的资源</li></ol><h3 id="从浏览器地址栏输入-url-到显示页面的步骤-以-http-为例">从浏览器地址栏输入 url 到显示页面的步骤(以 HTTP 为例)</h3><ol><li>在浏览器地址栏输入 URL</li><li>浏览器查看<strong>缓存</strong>，如果请求资源在缓存中并且新鲜，跳转到转码步骤<ol><li>如果资源未缓存，发起新请求</li><li>如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。</li><li>检验新鲜通常有两个 HTTP 头进行控制<code>Expires</code>和<code>Cache-Control</code>：<ul><li>HTTP1.0 提供 Expires，值为一个绝对时间表示缓存新鲜日期</li><li>HTTP1.1 增加了 Cache-Control: max-age=,值为以秒为单位的最大新鲜时间</li></ul></li></ol></li><li>浏览器<strong>解析 URL</strong>获取协议，主机，端口，path</li><li>浏览器<strong>组装一个 HTTP（GET）请求报文</strong></li><li>浏览器<strong>获取主机 ip 地址</strong>，过程如下：<ol><li>浏览器缓存</li><li>本机缓存</li><li>hosts 文件</li><li>路由器缓存</li><li>ISP DNS 缓存</li><li>DNS 递归查询（可能存在负载均衡导致每次 IP 不一样）</li></ol></li><li><strong>打开一个 socket 与目标 IP 地址，端口建立 TCP 链接</strong>，三次握手如下：<ol><li>客户端发送一个 TCP 的<strong>SYN=1，Seq=X</strong>的包到服务器端口</li><li>服务器发回<strong>SYN=1， ACK=X+1， Seq=Y</strong>的响应包</li><li>客户端发送<strong>ACK=Y+1， Seq=Z</strong></li></ol></li><li>TCP 链接建立后<strong>发送 HTTP 请求</strong></li><li>服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用 HTTP Host 头部判断请求的服务程序</li><li>服务器检查<strong>HTTP 请求头是否包含缓存验证信息</strong>如果验证缓存新鲜，返回<strong>304</strong>等对应状态码</li><li>处理程序读取完整请求并准备 HTTP 响应，可能需要查询数据库等操作</li><li>服务器将<strong>响应报文通过 TCP 连接发送回浏览器</strong></li><li>浏览器接收 HTTP 响应，然后根据情况选择<strong>关闭 TCP 连接或者保留重用，关闭 TCP 连接的四次握手如下</strong>：<ol><li>主动方发送<strong>Fin=1， Ack=Z， Seq= X</strong>报文</li><li>被动方发送<strong>ACK=X+1， Seq=Z</strong>报文</li><li>被动方发送<strong>Fin=1， ACK=X， Seq=Y</strong>报文</li><li>主动方发送<strong>ACK=Y， Seq=X</strong>报文</li></ol></li><li>浏览器检查响应状态吗：是否为 1XX，3XX， 4XX， 5XX，这些情况处理与 2XX 不同</li><li>如果资源可缓存，<strong>进行缓存</strong></li><li>对响应进行<strong>解码</strong>（例如 gzip 压缩）</li><li>根据资源类型决定如何处理（假设资源为 HTML 文档）</li><li><strong>解析 HTML 文档，构件 DOM 树，下载资源，构造 CSSOM 树，执行 js 脚本</strong>，这些操作没有严格的先后顺序，以下分别解释</li><li><strong>构建 DOM 树</strong>：<ol><li><strong>Tokenizing</strong>：根据 HTML 规范将字符流解析为标记</li><li><strong>Lexing</strong>：词法分析将标记转换为对象并定义属性和规则</li><li><strong>DOM construction</strong>：根据 HTML 标记关系将对象组成 DOM 树</li></ol></li><li>解析过程中遇到图片、样式表、js 文件，<strong>启动下载</strong></li><li>构建<strong>CSSOM 树</strong>：<ol><li><strong>Tokenizing</strong>：字符流转换为标记流</li><li><strong>Node</strong>：根据标记创建节点</li><li><strong>CSSOM</strong>：节点创建 CSSOM 树</li></ol></li><li><strong><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction">根据 DOM 树和 CSSOM 树构建渲染树</a></strong>:<ol><li>从 DOM 树的根节点遍历所有<strong>可见节点</strong>，不可见节点包括：1）<code>script</code>,<code>meta</code>这样本身不可见的标签。2)被 css 隐藏的节点，如<code>display: none</code></li><li>对每一个可见节点，找到恰当的 CSSOM 规则并应用</li><li>发布可视节点的内容和计算样式</li></ol></li><li><strong>js 解析如下</strong>：<ol><li>浏览器创建 Document 对象并解析 HTML，将解析到的元素和文本节点添加到文档中，此时<strong>document.readystate 为 loading</strong></li><li>HTML 解析器遇到<strong>没有 async 和 defer 的 script 时</strong>，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用 document.write()把文本插入到输入流中。<strong>同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作 script 和他们之前的文档内容</strong></li><li>当解析器遇到设置了<strong>async</strong>属性的 script 时，开始下载脚本并继续解析文档。脚本会在它<strong>下载完成后尽快执行</strong>，但是<strong>解析器不会停下来等它下载</strong>。异步脚本<strong>禁止使用 document.write()</strong>，它们可以访问自己 script 和之前的文档元素</li><li>当文档完成解析，document.readState 变成 interactive</li><li>所有<strong>defer</strong>脚本会<strong>按照在文档出现的顺序执行</strong>，延迟脚本<strong>能访问完整文档树</strong>，禁止使用 document.write()</li><li>浏览器<strong>在 Document 对象上触发 DOMContentLoaded 事件</strong></li><li>此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些<strong>内容完成载入并且所有异步脚本完成载入和执行</strong>，document.readState 变为 complete,window 触发 load 事件</li></ol></li><li><strong>显示页面</strong>（HTML 解析过程中会逐步显示页面）</li></ol><p><img src="./img/visit.svg" alt="HTTP访问过程"></p><h3 id="http-request-报文结构是怎样的">HTTP request 报文结构是怎样的</h3><p><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html">rfc2616</a>中进行了定义：</p><ol><li>首行是<strong>Request-Line</strong>包括：<strong>请求方法</strong>，<strong>请求 URI</strong>，<strong>协议版本</strong>，<strong>CRLF</strong></li><li>首行之后是若干行<strong>请求头</strong>，包括<strong>general-header</strong>，<strong>request-header</strong>或者<strong>entity-header</strong>，每个一行以 CRLF 结束</li><li>请求头和消息实体之间有一个<strong>CRLF 分隔</strong></li><li>根据实际请求需要可能包含一个<strong>消息实体</strong> 一个请求报文例子如下：</li></ol><pre><code>GET /Protocols/rfc2616/rfc2616-sec5.html HTTP/1.1
Host: www.w3.org
Connection: keep-alive
Cache-Control: max-age=0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36
Referer: https://www.google.com.hk/
Accept-Encoding: gzip,deflate,sdch
Accept-Language: zh-CN,zh;q=0.8,en;q=0.6
Cookie: authorstyle=yes
If-None-Match: &quot;2cc8-3e3073913b100&quot;
If-Modified-Since: Wed, 01 Sep 2004 13:24:52 GMT

name=qiu&amp;age=25
</code></pre><h3 id="http-response-报文结构是怎样的">HTTP response 报文结构是怎样的</h3><p><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html">rfc2616</a>中进行了定义：</p><ol><li>首行是状态行包括：<strong>HTTP 版本，状态码，状态描述</strong>，后面跟一个 CRLF</li><li>首行之后是<strong>若干行响应头</strong>，包括：<strong>通用头部，响应头部，实体头部</strong></li><li>响应头部和响应实体之间用<strong>一个 CRLF 空行</strong>分隔</li><li>最后是一个可能的<strong>消息实体</strong> 响应报文例子如下：</li></ol><pre><code>HTTP/1.1 200 OK
Date: Tue, 08 Jul 2014 05:28:43 GMT
Server: Apache/2
Last-Modified: Wed, 01 Sep 2004 13:24:52 GMT
ETag: &quot;40d7-3e3073913b100&quot;
Accept-Ranges: bytes
Content-Length: 16599
Cache-Control: max-age=21600
Expires: Tue, 08 Jul 2014 11:28:43 GMT
P3P: policyref=&quot;http://www.w3.org/2001/05/P3P/p3p.xml&quot;
Content-Type: text/html; charset=iso-8859-1

{&quot;name&quot;: &quot;qiu&quot;, &quot;age&quot;: 25}
</code></pre><h3 id="如何进行网站性能优化">如何进行网站性能优化</h3><p><a href="https://developer.yahoo.com/performance/rules.html">雅虎 Best Practices for Speeding Up Your Web Site</a>：</p><ul><li><p>content 方面</p><ol><li>减少 HTTP 请求：合并文件、CSS 精灵、inline Image</li><li>减少 DNS 查询：DNS 查询完成之前浏览器不能从这个主机下载任何任何文件。方法：DNS 缓存、将资源分布到恰当数量的主机名，平衡并行下载和 DNS 查询</li><li>避免重定向：多余的中间访问</li><li>使 Ajax 可缓存</li><li>非必须组件延迟加载</li><li>未来所需组件预加载</li><li>减少 DOM 元素数量</li><li>将资源放到不同的域下：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量</li><li>减少 iframe 数量</li><li>不要 404</li></ol></li><li><p>Server 方面</p><ol><li>使用 CDN</li><li>添加 Expires 或者 Cache-Control 响应头</li><li>对组件使用 Gzip 压缩</li><li>配置 ETag</li><li>Flush Buffer Early</li><li>Ajax 使用 GET 进行请求</li><li>避免空 src 的 img 标签</li></ol></li><li><p>Cookie 方面</p><ol><li>减小 cookie 大小</li><li>引入资源的域名不要包含 cookie</li></ol></li><li><p>css 方面</p><ol><li>将样式表放到页面顶部</li><li>不使用 CSS 表达式</li><li>使用<link>不使用@import</li><li>不使用 IE 的 Filter</li></ol></li><li><p>Javascript 方面</p><ol><li>将脚本放到页面底部</li><li>将 javascript 和 css 从外部引入</li><li>压缩 javascript 和 css</li><li>删除不需要的脚本</li><li>减少 DOM 访问</li><li>合理设计事件监听器</li></ol></li><li><p>图片方面</p><ol><li>优化图片：根据实际颜色需要选择色深、压缩</li><li>优化 css 精灵</li><li>不要在 HTML 中拉伸图片</li><li>保证 favicon.ico 小并且可缓存</li></ol></li><li><p>移动方面</p><ol><li>保证组件小于 25k</li><li>Pack Components into a Multipart Document</li></ol></li></ul><h3 id="什么是渐进增强">什么是渐进增强</h3><p>渐进增强是指在 web 设计时强调可访问性、语义化 HTML 标签、外部样式表和脚本。保证所有人都能访问页面的基本内容和功能同时为高级浏览器和高带宽用户提供更好的用户体验。核心原则如下:</p><ul><li>所有浏览器都必须能访问基本内容</li><li>所有浏览器都必须能使用基本功能</li><li>所有内容都包含在语义化标签中</li><li>通过外部 CSS 提供增强的布局</li><li>通过非侵入式、外部 javascript 提供增强功能</li><li>end-user web browser preferences are respected</li></ul><h3 id="http-状态码及其含义">HTTP 状态码及其含义</h3><p>参考<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html">RFC 2616</a></p><ul><li>1XX：信息状态码<ul><li><strong>100 Continue</strong>：客户端应当继续发送请求。这个临时相应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应</li><li><strong>101 Switching Protocols</strong>：服务器已经理解 le 客户端的请求，并将通过 Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到 Upgrade 消息头中定义的那些协议。</li></ul></li><li>2XX：成功状态码<ul><li><strong>200 OK</strong>：请求成功，请求所希望的响应头或数据体将随此响应返回</li><li><strong>201 Created</strong>：</li><li><strong>202 Accepted</strong>：</li><li><strong>203 Non-Authoritative Information</strong>：</li><li><strong>204 No Content</strong>：</li><li><strong>205 Reset Content</strong>：</li><li><strong>206 Partial Content</strong>：</li></ul></li><li>3XX：重定向<ul><li><strong>300 Multiple Choices</strong>：</li><li><strong>301 Moved Permanently</strong>：</li><li><strong>302 Found</strong>：</li><li><strong>303 See Other</strong>：</li><li><strong>304 Not Modified</strong>：</li><li><strong>305 Use Proxy</strong>：</li><li><strong>306 （unused）</strong>：</li><li><strong>307 Temporary Redirect</strong>：</li></ul></li><li>4XX：客户端错误<ul><li><strong>400 Bad Request</strong>:</li><li><strong>401 Unauthorized</strong>:</li><li><strong>402 Payment Required</strong>:</li><li><strong>403 Forbidden</strong>:</li><li><strong>404 Not Found</strong>:</li><li><strong>405 Method Not Allowed</strong>:</li><li><strong>406 Not Acceptable</strong>:</li><li><strong>407 Proxy Authentication Required</strong>:</li><li><strong>408 Request Timeout</strong>:</li><li><strong>409 Conflict</strong>:</li><li><strong>410 Gone</strong>:</li><li><strong>411 Length Required</strong>:</li><li><strong>412 Precondition Failed</strong>:</li><li><strong>413 Request Entity Too Large</strong>:</li><li><strong>414 Request-URI Too Long</strong>:</li><li><strong>415 Unsupported Media Type</strong>:</li><li><strong>416 Requested Range Not Satisfiable</strong>:</li><li><strong>417 Expectation Failed</strong>:</li></ul></li><li>5XX: 服务器错误<ul><li><strong>500 Internal Server Error</strong>:</li><li><strong>501 Not Implemented</strong>:</li><li><strong>502 Bad Gateway</strong>:</li><li><strong>503 Service Unavailable</strong>:</li><li><strong>504 Gateway Timeout</strong>:</li><li><strong>505 HTTP Version Not Supported</strong>:</li></ul></li></ul><h2 id="css-部分">$CSS 部分</h2><h3 id="css-选择器有哪些">CSS 选择器有哪些</h3><ol><li><strong>*通用选择器</strong>：选择所有元素，<strong>不参与计算优先级</strong>，兼容性 IE6+</li><li><strong>#X id 选择器</strong>：选择 id 值为 X 的元素，兼容性：IE6+</li><li><strong>.X 类选择器</strong>： 选择 class 包含 X 的元素，兼容性：IE6+</li><li><strong>X Y 后代选择器</strong>： 选择满足 X 选择器的后代节点中满足 Y 选择器的元素，兼容性：IE6+</li><li><strong>X 元素选择器</strong>： 选择标所有签为 X 的元素，兼容性：IE6+</li><li><strong>:link，:visited，:focus，:hover，:active 链接状态</strong>： 选择特定状态的链接元素，顺序 LoVe HAte，兼容性: IE4+</li><li><strong>X + Y 直接兄弟选择器</strong>：在<strong>X 之后第一个兄弟节点</strong>中选择满足 Y 选择器的元素，兼容性： IE7+</li><li><strong>X &gt; Y 子选择器</strong>： 选择 X 的子元素中满足 Y 选择器的元素，兼容性： IE7+</li><li><strong>X ~ Y 兄弟</strong>： 选择<strong>X 之后所有兄弟节点</strong>中满足 Y 选择器的元素，兼容性： IE7+</li><li><strong>[attr]</strong>：选择所有设置了 attr 属性的元素，兼容性 IE7+</li><li><strong>[attr=value]</strong>：选择属性值刚好为 value 的元素</li><li><strong>[attr~=value]</strong>：选择属性值为空白符分隔，其中一个的值刚好是 value 的元素</li><li><strong>[attr|=value]</strong>：选择属性值刚好为 value 或者 value-开头的元素</li><li><strong>[attr^=value]</strong>：选择属性值以 value 开头的元素</li><li><strong>[attr$=value]</strong>：选择属性值以 value 结尾的元素</li><li><strong>[attr*=value]</strong>：选择属性值中包含 value 的元素</li><li><strong>[:checked]</strong>：选择单选框，复选框，下拉框中选中状态下的元素，兼容性：IE9+</li><li><strong>X:after, X::after</strong>：after 伪元素，选择元素虚拟子元素（元素的最后一个子元素），CSS3 中::表示伪元素。兼容性:after 为 IE8+，::after 为 IE9+</li><li><strong>:hover</strong>：鼠标移入状态的元素，兼容性 a 标签 IE4+， 所有元素 IE7+</li><li><strong>:not(selector)</strong>：选择不符合 selector 的元素。<strong>不参与计算优先级</strong>，兼容性：IE9+</li><li><strong>::first-letter</strong>：伪元素，选择块元素第一行的第一个字母，兼容性 IE5.5+</li><li><strong>::first-line</strong>：伪元素，选择块元素的第一行，兼容性 IE5.5+</li><li><strong>:nth-child(an + b)</strong>：伪类，选择前面有 an + b - 1 个兄弟节点的元素，其中 n &gt;= 0， 兼容性 IE9+</li><li><strong>:nth-last-child(an + b)</strong>：伪类，选择后面有 an + b - 1 个兄弟节点的元素 其中 n &gt;= 0，兼容性 IE9+</li><li><strong>X:nth-of-type(an+b)</strong>：伪类，X 为选择器，<strong>解析得到元素标签</strong>，选择<strong>前面</strong>有 an + b - 1 个<strong>相同标签</strong>兄弟节点的元素。兼容性 IE9+</li><li><strong>X:nth-last-of-type(an+b)</strong>：伪类，X 为选择器，解析得到元素标签，选择<strong>后面</strong>有 an+b-1 个相同<strong>标签</strong>兄弟节点的元素。兼容性 IE9+</li><li><strong>X:first-child</strong>：伪类，选择满足 X 选择器的元素，且这个元素是其父节点的第一个子元素。兼容性 IE7+</li><li><strong>X:last-child</strong>：伪类，选择满足 X 选择器的元素，且这个元素是其父节点的最后一个子元素。兼容性 IE9+</li><li><strong>X:only-child</strong>：伪类，选择满足 X 选择器的元素，且这个元素是其父元素的唯一子元素。兼容性 IE9+</li><li><strong>X:only-of-type</strong>：伪类，选择 X 选择的元素，<strong>解析得到元素标签</strong>，如果该元素没有相同类型的兄弟节点时选中它。兼容性 IE9+</li><li><strong>X:first-of-type</strong>：伪类，选择 X 选择的元素，<strong>解析得到元素标签</strong>，如果该元素 是此此类型元素的第一个兄弟。选中它。兼容性 IE9+</li></ol><h3 id="css-sprite-是什么-有什么优缺点">css sprite 是什么,有什么优缺点</h3><p>概念：将多个小图片拼接到一个图片中。通过 background-position 和元素尺寸调节需要显示的背景图案。</p><p>优点：</p><ol><li>减少 HTTP 请求数，极大地提高页面加载速度</li><li>增加图片信息重复度，提高压缩比，减少图片大小</li><li>更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现</li></ol><p>缺点：</p><ol><li>图片合并麻烦</li><li>维护麻烦，修改一个图片可能需要重新布局整个图片，样式</li></ol><h3 id="display-none-与-visibility-hidden-的区别"><code>display: none;</code>与<code>visibility: hidden;</code>的区别</h3><p>联系：它们都能让元素不可见</p><p>区别：</p><ol><li>display:none;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；visibility: hidden;不会让元素从渲染树消失，渲染时元素继续占据空间，只是内容不可见。</li><li>display: none;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；visibility: hidden;是继承属性，子孙节点由于继承了 hidden 而消失，通过设置 visibility: visible，可以让子孙节点显示。</li><li>修改常规流中元素的 display 通常会造成文档重排。修改 visibility 属性只会造成本元素的重绘。</li><li>读屏器不会读取 display: none;元素内容；会读取 visibility: hidden;元素内容。</li></ol><h3 id="css-hack-原理及常用-hack">css hack 原理及常用 hack</h3><p>原理：利用<strong>不同浏览器对 CSS 的支持和解析结果不一样</strong>编写针对特定浏览器样式。常见的 hack 有 1）属性 hack。2）选择器 hack。3）IE 条件注释</p><ul><li>IE 条件注释：适用于[IE5, IE9]常见格式如下</li></ul><pre><code class="language-js">&lt;!--[if IE 6]&gt;
Special instructions for IE 6 here
&lt;![endif]--&gt;
</code></pre><ul><li>选择器 hack：不同浏览器对选择器的支持不一样</li></ul><pre><code class="language-css">/***** Selector Hacks ******/

/* IE6 and below */
* html #uno {
  color: red;
}

/* IE7 */
*:first-child + html #dos {
  color: red;
}

/* IE7, FF, Saf, Opera  */
html &gt; body #tres {
  color: red;
}

/* IE8, FF, Saf, Opera (Everything but IE 6,7) */
html&gt;/**/body #cuatro {
  color: red;
}

/* Opera 9.27 and below, safari 2 */
html:first-child #cinco {
  color: red;
}

/* Safari 2-3 */
html[xmlns*=''] body:last-child #seis {
  color: red;
}

/* safari 3+, chrome 1+, opera9+, ff 3.5+ */
body:nth-of-type(1) #siete {
  color: red;
}

/* safari 3+, chrome 1+, opera9+, ff 3.5+ */
body:first-of-type #ocho {
  color: red;
}

/* saf3+, chrome1+ */
@media screen and (-webkit-min-device-pixel-ratio: 0) {
  #diez {
    color: red;
  }
}

/* iPhone / mobile webkit */
@media screen and (max-device-width: 480px) {
  #veintiseis {
    color: red;
  }
}

/* Safari 2 - 3.1 */
html[xmlns*='']:root #trece {
  color: red;
}

/* Safari 2 - 3.1, Opera 9.25 */
*|html[xmlns*=''] #catorce {
  color: red;
}

/* Everything but IE6-8 */
:root * &gt; #quince {
  color: red;
}

/* IE7 */
* + html #dieciocho {
  color: red;
}

/* Firefox only. 1+ */
#veinticuatro,
x:-moz-any-link {
  color: red;
}

/* Firefox 3.0+ */
#veinticinco,
x:-moz-any-link,
x:default {
  color: red;
}
</code></pre><ul><li>属性 hack：不同浏览器解析 bug 或方法</li></ul><pre><code>/* IE6 */
#once { _color: blue }

/* IE6, IE7 */
#doce { *color: blue; /* or #color: blue */ }

/* Everything but IE6 */
#diecisiete { color/**/: blue }

/* IE6, IE7, IE8 */
#diecinueve { color: blue\9; }

/* IE7, IE8 */
#veinte { color/*\**/: blue\9; }

/* IE6, IE7 -- acts as an !important */
#veintesiete { color: blue !ie; } /* string after ! can be anything */
</code></pre><h3 id="specified-value-computed-value-used-value-计算方法">specified value,computed value,used value 计算方法</h3><ul><li><p>specified value: 计算方法如下：</p><ol><li>如果样式表设置了一个值，使用这个值</li><li>如果没有设值，且这个属性是继承属性，从父元素继承</li><li>如果没有设值，并且不是继承属性，则使用 css 规范指定的初始值</li></ol></li><li><p>computed value: 以 specified value 根据规范定义的行为进行计算，通常将相对值计算为绝对值，例如 em 根据 font-size 进行计算。一些使用百分数并且需要布局来决定最终值的属性，如 width，margin。百分数就直接作为 computed value。line-height 的无单位值也直接作为 computed value。这些值将在计算 used value 时得到绝对值。<strong>computed value 的主要作用是用于继承</strong></p></li><li><p>used value：属性计算后的最终值，对于大多数属性可以通过 window.getComputedStyle 获得，尺寸值单位为像素。以下属性依赖于布局，</p><ul><li>background-position</li><li>bottom, left, right, top</li><li>height, width</li><li>margin-bottom, margin-left, margin-right, margin-top</li><li>min-height, min-width</li><li>padding-bottom, padding-left, padding-right, padding-top</li><li>text-indent</li></ul></li></ul><h3 id="link-与-import-的区别"><code>link</code>与<code>@import</code>的区别</h3><ol><li><code>link</code>是 HTML 方式， <code>@import</code>是 CSS 方式</li><li><code>link</code>最大限度支持并行下载，<code>@import</code>过多嵌套导致串行下载，出现<a href="http://www.bluerobot.com/web/css/fouc.asp/">FOUC</a></li><li><code>link</code>可以通过<code>rel=&quot;alternate stylesheet&quot;</code>指定候选样式</li><li>浏览器对<code>link</code>支持早于<code>@import</code>，可以使用<code>@import</code>对老浏览器隐藏样式</li><li><code>@import</code>必须在样式规则之前，可以在 css 文件中引用其他文件</li><li>总体来说：<strong><a href="http://www.stevesouders.com/blog/2009/04/09/dont-use-import/">link 优于@import</a></strong></li></ol><h3 id="display-block-和-display-inline-的区别"><code>display: block;</code>和<code>display: inline;</code>的区别</h3><p><code>block</code>元素特点：</p><p>1.处于常规流中时，如果<code>width</code>没有设置，会自动填充满父容器 2.可以应用<code>margin/padding</code> 3.在没有设置高度的情况下会扩展高度以包含常规流中的子元素 4.处于常规流中时布局时在前后元素位置之间（独占一个水平空间） 5.忽略<code>vertical-align</code></p><p><code>inline</code>元素特点</p><p>1.水平方向上根据<code>direction</code>依次布局 2.不会在元素前后进行换行 3.受<code>white-space</code>控制 4.<code>margin/padding</code>在竖直方向上无效，水平方向上有效 5.<code>width/height</code>属性对非替换行内元素无效，宽度由元素内容决定 6.非替换行内元素的行框高由<code>line-height</code>确定，替换行内元素的行框高由<code>height</code>,<code>margin</code>,<code>padding</code>,<code>border</code>决定 6.浮动或绝对定位时会转换为<code>block</code> 7.<code>vertical-align</code>属性生效</p><h3 id="png-gif-jpg-的区别及如何选">PNG,GIF,JPG 的区别及如何选</h3><p>参考资料： <a href="http://www.yuiblog.com/blog/2008/11/04/imageopt-2/">选择正确的图片格式</a> <strong>GIF</strong>:</p><ol><li>8 位像素，256 色</li><li>无损压缩</li><li>支持简单动画</li><li>支持 boolean 透明</li><li>适合简单动画</li></ol><p><strong>JPEG</strong>：</p><ol><li>颜色限于 256</li><li>有损压缩</li><li>可控制压缩质量</li><li>不支持透明</li><li>适合照片</li></ol><p><strong>PNG</strong>：</p><ol><li>有 PNG8 和 truecolor PNG</li><li>PNG8 类似 GIF 颜色上限为 256，文件小，支持 alpha 透明度，无动画</li><li>适合图标、背景、按钮</li></ol><h3 id="css-有哪些继承属性">CSS 有哪些继承属性</h3><ul><li>关于文字排版的属性如：<ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/font">font</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/word-break">word-break</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/letter-spacing">letter-spacing</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/text-align">text-align</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/text-rendering">text-rendering</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/word-spacing">word-spacing</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/white-space">white-space</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/text-indent">text-indent</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/text-transform">text-transform</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow">text-shadow</a></li></ul></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/line-height">line-height</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/color">color</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/visibility">visibility</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/cursor">cursor</a></li></ul><h3 id="ie6-浏览器有哪些常见的-bug-缺陷或者与标准不一致的地方-如何解决">IE6 浏览器有哪些常见的 bug,缺陷或者与标准不一致的地方,如何解决</h3><ul><li>IE6 不支持 min-height，解决办法使用 css hack：</li></ul><pre><code>.target {
    min-height: 100px;
    height: auto !important;
    height: 100px;   // IE6下内容高度超过会自动扩展高度
}
</code></pre><ul><li><p><code>ol</code>内<code>li</code>的序号全为 1，不递增。解决方法：为 li 设置样式<code>display: list-item;</code></p></li><li><p>未定位父元素<code>overflow: auto;</code>，包含<code>position: relative;</code>子元素，子元素高于父元素时会溢出。解决办法：1）子元素去掉<code>position: relative;</code>; 2）不能为子元素去掉定位时，父元素<code>position: relative;</code></p></li></ul><pre><code>&lt;style type=&quot;text/css&quot;&gt;
.outer {
    width: 215px;
    height: 100px;
    border: 1px solid red;
    overflow: auto;
    position: relative;  /* 修复bug */
}
.inner {
    width: 100px;
    height: 200px;
    background-color: purple;
    position: relative;
}
&lt;/style&gt;

&lt;div class=&quot;outer&quot;&gt;
    &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre><ul><li>IE6 只支持<code>a</code>标签的<code>:hover</code>伪类，解决方法：使用 js 为元素监听 mouseenter，mouseleave 事件，添加类实现效果：</li></ul><pre><code>&lt;style type=&quot;text/css&quot;&gt;
.p:hover,
.hover {
    background: purple;
}
&lt;/style&gt;

&lt;p class=&quot;p&quot; id=&quot;target&quot;&gt;aaaa bbbbb&lt;span&gt;DDDDDDDDDDDd&lt;/span&gt; aaaa lkjlkjdf j&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
function addClass(elem, cls) {
    if (elem.className) {
        elem.className += ' ' + cls;
    } else {
        elem.className = cls;
    }
}
function removeClass(elem, cls) {
    var className = ' ' + elem.className + ' ';
    var reg = new RegExp(' +' + cls + ' +', 'g');
    elem.className = className.replace(reg, ' ').replace(/^ +| +$/, '');
}

var target = document.getElementById('target');
if (target.attachEvent) {
    target.attachEvent('onmouseenter', function () {
        addClass(target, 'hover');
    });
    target.attachEvent('onmouseleave', function () {
        removeClass(target, 'hover');
    })
}
&lt;/script&gt;
</code></pre><ul><li>IE5-8 不支持<code>opacity</code>，解决办法：</li></ul><pre><code>.opacity {
    opacity: 0.4
    filter: alpha(opacity=60); /* for IE5-7 */
    -ms-filter: &quot;progid:DXImageTransform.Microsoft.Alpha(Opacity=60)&quot;; /* for IE 8*/
}
</code></pre><ul><li>IE6 在设置<code>height</code>小于<code>font-size</code>时高度值为<code>font-size</code>，解决办法：<code>font-size: 0;</code></li><li>IE6 不支持 PNG 透明背景，解决办法: <strong>IE6 下使用 gif 图片</strong></li><li>IE6-7 不支持<code>display: inline-block</code>解决办法：设置 inline 并触发 hasLayout</li></ul><pre><code>    display: inline-block;
    *display: inline;
    *zoom: 1;
</code></pre><ul><li>IE6 下浮动元素在浮动方向上与父元素边界接触元素的外边距会加倍。解决办法： 1）使用 padding 控制间距。 2）浮动元素<code>display: inline;</code>这样解决问题且无任何副作用：css 标准规定浮动元素 display:inline 会自动调整为 block</li><li>通过为块级元素设置宽度和左右 margin 为 auto 时，IE6 不能实现水平居中，解决方法：为父元素设置<code>text-align: center;</code></li></ul><h3 id="容器包含若干浮动元素时如何清理-包含-浮动">容器包含若干浮动元素时如何清理(包含)浮动</h3><ol><li>容器元素闭合标签前添加额外元素并设置<code>clear: both</code></li><li>父元素触发块级格式化上下文(见块级可视化上下文部分)</li><li>设置容器元素伪元素进行清理<a href="http://nicolasgallagher.com/micro-clearfix-hack/">推荐的清理浮动方法</a></li></ol><pre><code>/**
* 在标准浏览器下使用
* 1 content内容为空格用于修复opera下文档中出现
*   contenteditable属性时在清理浮动元素上下的空白
* 2 使用display使用table而不是block：可以防止容器和
*   子元素top-margin折叠,这样能使清理效果与BFC，IE6/7
*   zoom: 1;一致
**/

.clearfix:before,
.clearfix:after {
    content: &quot; &quot;; /* 1 */
    display: table; /* 2 */
}

.clearfix:after {
    clear: both;
}

/**
* IE 6/7下使用
* 通过触发hasLayout实现包含浮动
**/
.clearfix {
    *zoom: 1;
}
</code></pre><h3 id="什么是-fouc-如何避免">什么是 FOUC?如何避免</h3><p>Flash Of Unstyled Content：用户定义样式表加载之前浏览器使用默认样式显示文档，用户样式加载渲染之后再从新显示文档，造成页面闪烁。<strong>解决方法</strong>：把样式表放到文档的<code>head</code></p><h3 id="如何创建块级格式化上下文-block-formatting-context-bfc-有什么用">如何创建块级格式化上下文(block formatting context),BFC 有什么用</h3><p>创建规则：</p><ol><li>根元素</li><li>浮动元素（<code>float</code>不是<code>none</code>）</li><li>绝对定位元素（<code>position</code>取值为<code>absolute</code>或<code>fixed</code>）</li><li><code>display</code>取值为<code>inline-block</code>,<code>table-cell</code>, <code>table-caption</code>,<code>flex</code>, <code>inline-flex</code>之一的元素</li><li><code>overflow</code>不是<code>visible</code>的元素</li></ol><p>作用：</p><ol><li>可以包含浮动元素</li><li>不被浮动元素覆盖</li><li>阻止父子元素的 margin 折叠</li></ol><h3 id="display-float-position-的关系">display,float,position 的关系</h3><ol><li>如果<code>display</code>为 none，那么 position 和 float 都不起作用，这种情况下元素不产生框</li><li>否则，如果 position 值为 absolute 或者 fixed，框就是绝对定位的，float 的计算值为 none，display 根据下面的表格进行调整。</li><li>否则，如果 float 不是 none，框是浮动的，display 根据下表进行调整</li><li>否则，如果元素是根元素，display 根据下表进行调整</li><li>其他情况下 display 的值为指定值 总结起来：<strong>绝对定位、浮动、根元素都需要调整<code>display</code></strong> <img src="img/display-adjust.png" alt="display转换规则"></li></ol><h3 id="外边距折叠-collapsing-margins">外边距折叠(collapsing margins)</h3><p>毗邻的两个或多个<code>margin</code>会合并成一个 margin，叫做外边距折叠。规则如下：</p><ol><li>两个或多个毗邻的普通流中的块元素垂直方向上的 margin 会折叠</li><li>浮动元素/inline-block 元素/绝对定位元素的 margin 不会和垂直方向上的其他元素的 margin 折叠</li><li>创建了块级格式化上下文的元素，不会和它的子元素发生 margin 折叠</li><li>元素自身的 margin-bottom 和 margin-top 相邻时也会折叠</li></ol><h3 id="如何确定一个元素的包含块-containing-block">如何确定一个元素的包含块(containing block)</h3><ol><li>根元素的包含块叫做初始包含块，在连续媒体中他的尺寸与 viewport 相同并且 anchored at the canvas origin；对于 paged media，它的尺寸等于 page area。初始包含块的 direction 属性与根元素相同。</li><li><code>position</code>为<code>relative</code>或者<code>static</code>的元素，它的包含块由最近的块级（<code>display</code>为<code>block</code>,<code>list-item</code>, <code>table</code>）祖先元素的<strong>内容框</strong>组成</li><li>如果元素<code>position</code>为<code>fixed</code>。对于连续媒体，它的包含块为 viewport；对于 paged media，包含块为 page area</li><li><p>如果元素<code>position</code>为<code>absolute</code>，它的包含块由祖先元素中最近一个<code>position</code>为<code>relative</code>,<code>absolute</code>或者<code>fixed</code>的元素产生，规则如下：</p><ul><li>如果祖先元素为行内元素，the containing block is the bounding box around the <strong>padding boxes</strong> of the first and the last inline boxes generated for that element.</li><li>其他情况下包含块由祖先节点的<strong>padding edge</strong>组成</li></ul></li></ol><p>如果找不到定位的祖先元素，包含块为<strong>初始包含块</strong></p><h3 id="stacking-context-布局规则">stacking context,布局规则</h3><p>z 轴上的默认层叠顺序如下（从下到上）：</p><ol><li>根元素的边界和背景</li><li>常规流中的元素按照 html 中顺序</li><li>浮动块</li><li>positioned 元素按照 html 中出现顺序</li></ol><p>如何创建 stacking context：</p><ol><li>根元素</li><li>z-index 不为 auto 的定位元素</li><li>a flex item with a z-index value other than &lsquo;auto&rsquo;</li><li>opacity 小于 1 的元素</li><li>在移动端 webkit 和 chrome22+，z-index 为 auto，position: fixed 也将创建新的 stacking context</li></ol><h3 id="如何水平居中一个元素">如何水平居中一个元素</h3><ul><li>如果需要居中的元素为<strong>常规流中 inline 元素</strong>，为父元素设置<code>text-align: center;</code>即可实现</li><li>如果需要居中的元素为<strong>常规流中 block 元素</strong>，1）为元素设置宽度，2）设置左右 margin 为 auto。3）IE6 下需在父元素上设置<code>text-align: center;</code>,再给子元素恢复需要的值</li></ul><pre><code>&lt;body&gt;
    &lt;div class=&quot;content&quot;&gt;
    aaaaaa aaaaaa a a a a a a a a
    &lt;/div&gt;
&lt;/body&gt;

&lt;style&gt;
    body {
        background: #DDD;
        text-align: center; /* 3 */
    }
    .content {
        width: 500px;      /* 1 */
        text-align: left;  /* 3 */
        margin: 0 auto;    /* 2 */

        background: purple;
    }
&lt;/style&gt;
</code></pre><ul><li>如果需要居中的元素为<strong>浮动元素</strong>，1）为元素设置宽度，2）<code>position: relative;</code>，3）浮动方向偏移量（left 或者 right）设置为 50%，4）浮动方向上的 margin 设置为元素宽度一半乘以-1</li></ul><pre><code>&lt;body&gt;
    &lt;div class=&quot;content&quot;&gt;
    aaaaaa aaaaaa a a a a a a a a
    &lt;/div&gt;
&lt;/body&gt;

&lt;style&gt;
    body {
        background: #DDD;
    }
    .content {
        width: 500px;         /* 1 */
        float: left;

        position: relative;   /* 2 */
        left: 50%;            /* 3 */
        margin-left: -250px;  /* 4 */

        background-color: purple;
    }
&lt;/style&gt;
</code></pre><ul><li>如果需要居中的元素为<strong>绝对定位元素</strong>，1）为元素设置宽度，2）偏移量设置为 50%，3）偏移方向外边距设置为元素宽度一半乘以-1</li></ul><pre><code>&lt;body&gt;
    &lt;div class=&quot;content&quot;&gt;
    aaaaaa aaaaaa a a a a a a a a
    &lt;/div&gt;
&lt;/body&gt;

&lt;style&gt;
    body {
        background: #DDD;
        position: relative;
    }
    .content {
        width: 800px;

        position: absolute;
        left: 50%;
        margin-left: -400px;

        background-color: purple;
    }
&lt;/style&gt;
</code></pre><ul><li>如果需要居中的元素为<strong>绝对定位元素</strong>，1）为元素设置宽度，2）设置左右偏移量都为 0,3）设置左右外边距都为 auto</li></ul><pre><code>&lt;body&gt;
    &lt;div class=&quot;content&quot;&gt;
    aaaaaa aaaaaa a a a a a a a a
    &lt;/div&gt;
&lt;/body&gt;

&lt;style&gt;
    body {
        background: #DDD;
        position: relative;
    }
    .content {
        width: 800px;

        position: absolute;
        margin: 0 auto;
        left: 0;
        right: 0;

        background-color: purple;
    }
&lt;/style&gt;
</code></pre><h3 id="如何竖直居中一个元素">如何竖直居中一个元素</h3><p>参考资料：<a href="http://www.vanseodesign.com/css/vertical-centering/">6 Methods For Vertical Centering With CSS</a>。 <a href="http://blog.csdn.net/freshlover/article/details/11579669">盘点 8 种 CSS 实现垂直居中</a></p><ul><li>需要居中元素为<strong>单行文本</strong>，为包含文本的元素设置大于<code>font-size</code>的<code>line-height</code>：</li></ul><pre><code>&lt;p class=&quot;text&quot;&gt;center text&lt;/p&gt;

&lt;style&gt;
.text {
    line-height: 200px;
}
&lt;/style&gt;
</code></pre><h2 id="javascript-概念部分">$javascript 概念部分</h2><h3 id="dom-元素-e-的-e-getattribute-propname-和-e-propname-有什么区别和联系">DOM 元素 e 的 e.getAttribute(propName)和 e.propName 有什么区别和联系</h3><ul><li>e.getAttribute()，是标准 DOM 操作文档元素属性的方法，具有通用性可在任意文档上使用，返回元素在源文件中<strong>设置的属性</strong></li><li>e.propName 通常是在 HTML 文档中访问特定元素的<strong>特性</strong>，浏览器解析元素后生成对应对象（如 a 标签生成 HTMLAnchorElement），这些对象的特性会根据特定规则结合属性设置得到，对于没有对应特性的属性，只能使用 getAttribute 进行访问</li><li>e.getAttribute()返回值是源文件中设置的值，类型是字符串或者 null（有的实现返回&rdquo;&ldquo;）</li><li>e.propName 返回值可能是字符串、布尔值、对象、undefined 等</li><li>大部分 attribute 与 property 是一一对应关系，修改其中一个会影响另一个，如 id，title 等属性</li><li>一些布尔属性<code>&lt;input hidden/&gt;</code>的检测设置需要 hasAttribute 和 removeAttribute 来完成，或者设置对应 property</li><li>像<code>&lt;a href=&quot;../index.html&quot;&gt;link&lt;/a&gt;</code>中 href 属性，转换成 property 的时候需要通过转换得到完整 URL</li><li>一些 attribute 和 property 不是一一对应如：form 控件中<code>&lt;input value=&quot;hello&quot;/&gt;</code>对应的是 defaultValue，修改或设置 value property 修改的是控件当前值，setAttribute 修改 value 属性不会改变 value property</li></ul><h3 id="offsetwidth-offsetheight-clientwidth-clientheight-与-scrollwidth-scrollheight-的区别">offsetWidth/offsetHeight,clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别</h3><ul><li>offsetWidth/offsetHeight 返回值包含<strong>content + padding + border</strong>，效果与 e.getBoundingClientRect()相同</li><li>clientWidth/clientHeight 返回值只包含<strong>content + padding</strong>，如果有滚动条，也<strong>不包含滚动条</strong></li><li>scrollWidth/scrollHeight 返回值包含<strong>content + padding + 溢出内容的尺寸</strong></li></ul><p><a href="http://msdn.microsoft.com/en-us/library/ie/hh781509(v=vs.85).aspx">Measuring Element Dimension and Location with CSSOM in Windows Internet Explorer 9</a></p><p><img src="img/element-size.png" alt="元素尺寸"></p><h3 id="xmlhttprequest-通用属性和方法">XMLHttpRequest 通用属性和方法</h3><ol><li><code>readyState</code>:表示请求状态的整数，取值：</li></ol><ul><li>UNSENT（0）：对象已创建</li><li>OPENED（1）：open()成功调用，在这个状态下，可以为 xhr 设置请求头，或者使用 send()发送请求</li><li>HEADERS_RECEIVED(2)：所有重定向已经自动完成访问，并且最终响应的 HTTP 头已经收到</li><li>LOADING(3)：响应体正在接收</li><li>DONE(4)：数据传输完成或者传输产生错误</li></ul><ol><li><code>onreadystatechange</code>：readyState 改变时调用的函数</li><li><code>status</code>：服务器返回的 HTTP 状态码（如，200， 404）</li><li><code>statusText</code>:服务器返回的 HTTP 状态信息（如，OK，No Content）</li><li><code>responseText</code>:作为字符串形式的来自服务器的完整响应</li><li><code>responseXML</code>: Document 对象，表示服务器的响应解析成的 XML 文档</li><li><code>abort()</code>:取消异步 HTTP 请求</li><li><code>getAllResponseHeaders()</code>: 返回一个字符串，包含响应中服务器发送的全部 HTTP 报头。每个报头都是一个用冒号分隔开的名/值对，并且使用一个回车/换行来分隔报头行</li><li><code>getResponseHeader(headerName)</code>:返回 headName 对应的报头值</li><li><code>open(method, url, asynchronous [, user, password])</code>:初始化准备发送到服务器上的请求。method 是 HTTP 方法，不区分大小写；url 是请求发送的相对或绝对 URL；asynchronous 表示请求是否异步；user 和 password 提供身份验证</li><li><code>setRequestHeader(name, value)</code>:设置 HTTP 报头</li><li><code>send(body)</code>:对服务器请求进行初始化。参数 body 包含请求的主体部分，对于 POST 请求为键值对字符串；对于 GET 请求，为 null</li></ol><h3 id="focus-blur-与-focusin-focusout-的区别与联系">focus/blur 与 focusin/focusout 的区别与联系</h3><ol><li>focus/blur 不冒泡，focusin/focusout 冒泡</li><li>focus/blur 兼容性好，focusin/focusout 在除 FireFox 外的浏览器下都保持良好兼容性，如需使用事件托管，可考虑在 FireFox 下使用事件捕获 elem.addEventListener(&lsquo;focus&rsquo;, handler, true)</li><li>可获得焦点的元素：<ol><li>window</li><li>链接被点击或键盘操作</li><li>表单空间被点击或键盘操作</li><li>设置<code>tabindex</code>属性的元素被点击或键盘操作</li></ol></li></ol><h3 id="mouseover-mouseout-与-mouseenter-mouseleave-的区别与联系">mouseover/mouseout 与 mouseenter/mouseleave 的区别与联系</h3><ol><li>mouseover/mouseout 是标准事件，<strong>所有浏览器都支持</strong>；mouseenter/mouseleave 是 IE5.5 引入的特有事件后来被 DOM3 标准采纳，现代标准浏览器也支持</li><li>mouseover/mouseout 是<strong>冒泡</strong>事件；mouseenter/mouseleave<strong>不冒泡</strong>。需要为<strong>多个元素监听鼠标移入/出事件时，推荐 mouseover/mouseout 托管，提高性能</strong></li><li>标准事件模型中 event.target 表示发生移入/出的元素,<strong>vent.relatedTarget</strong>对应移出/如元素；在老 IE 中 event.srcElement 表示发生移入/出的元素，<strong>event.toElement</strong>表示移出的目标元素，<strong>event.fromElement</strong>表示移入时的来源元素</li></ol><p>例子：鼠标从 div#target 元素移出时进行处理，判断逻辑如下：</p><pre><code>&lt;div id=&quot;target&quot;&gt;&lt;span&gt;test&lt;/span&gt;&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
var target = document.getElementById('target');
if (target.addEventListener) {
  target.addEventListener('mouseout', mouseoutHandler, false);
} else if (target.attachEvent) {
  target.attachEvent('onmouseout', mouseoutHandler);
}

function mouseoutHandler(e) {
  e = e || window.event;
  var target = e.target || e.srcElement;

  // 判断移出鼠标的元素是否为目标元素
  if (target.id !== 'target') {
    return;
  }

  // 判断鼠标是移出元素还是移到子元素
  var relatedTarget = event.relatedTarget || e.toElement;
  while (relatedTarget !== target
    &amp;&amp; relatedTarget.nodeName.toUpperCase() !== 'BODY') {
    relatedTarget = relatedTarget.parentNode;
  }

  // 如果相等，说明鼠标在元素内部移动
  if (relatedTarget === target) {
    return;
  }

  // 执行需要操作
  //alert('鼠标移出');

}
&lt;/script&gt;
</code></pre><h3 id="sessionstorage-localstorage-cookie-区别">sessionStorage,localStorage,cookie 区别</h3><ol><li>都会在浏览器端保存，有大小限制，同源限制</li><li>cookie 会在请求时发送到服务器，作为会话标识，服务器可修改 cookie；web storage 不会发送到服务器</li><li>cookie 有 path 概念，子路径可以访问父路径 cookie，父路径不能访问子路径 cookie</li><li>有效期：cookie 在设置的有效期内有效，默认为浏览器关闭；sessionStorage 在窗口关闭前有效，localStorage 长期有效，直到用户删除</li><li>共享：sessionStorage 不能共享，localStorage 在同源文档之间共享，cookie 在同源且符合 path 规则的文档之间共享</li><li>localStorage 的修改会促发其他文档窗口的 update 事件</li><li>cookie 有 secure 属性要求 HTTPS 传输</li><li>浏览器不能保存超过 300 个 cookie，单个服务器不能超过 20 个，每个 cookie 不能超过 4k。web storage 大小支持能达到 5M</li></ol><h3 id="javascript-跨域通信">javascript 跨域通信</h3><p>同源：两个文档同源需满足</p><ol><li>协议相同</li><li>域名相同</li><li>端口相同</li></ol><p>跨域通信：js 进行 DOM 操作、通信时如果目标与当前窗口不满足同源条件，浏览器为了安全会阻止跨域操作。跨域通信通常有以下方法</p><ul><li>如果是 log 之类的简单<strong>单项通信</strong>，新建<code>&lt;img&gt;</code>,<code>&lt;script&gt;</code>,<code>&lt;link&gt;</code>,<code>&lt;iframe&gt;</code>元素，通过 src，href 属性设置为目标 url。实现跨域请求</li><li>如果请求<strong>json 数据</strong>，使用<code>&lt;script&gt;</code>进行 jsonp 请求</li><li>现代浏览器中<strong>多窗口通信</strong>使用 HTML5 规范的 targetWindow.postMessage(data, origin);其中 data 是需要发送的对象，origin 是目标窗口的 origin。window.addEventListener(&lsquo;message&rsquo;, handler, false);handler 的 event.data 是 postMessage 发送来的数据，event.origin 是发送窗口的 origin，event.source 是发送消息的窗口引用</li><li>内部服务器代理请求跨域 url，然后返回数据</li><li>跨域请求数据，现代浏览器可使用 HTML5 规范的 CORS 功能，只要目标服务器返回 HTTP 头部<strong><code>Access-Control-Allow-Origin: *</code></strong>即可像普通 ajax 一样访问跨域资源</li></ul><h3 id="javascript-有哪几种数据类型">javascript 有哪几种数据类型</h3><p>六种基本数据类型</p><ul><li>undefined</li><li>null</li><li>string</li><li>boolean</li><li>number</li><li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Symbol">symbol</a>(ES6)</li></ul><p>一种引用类型</p><ul><li>Object</li></ul><h3 id="什么闭包-闭包有什么用">什么闭包,闭包有什么用</h3><p><strong>闭包是在某个作用域内定义的函数，它可以访问这个作用域内的所有变量</strong>。闭包作用域链通常包括三个部分：</p><ol><li>函数本身作用域。</li><li>闭包定义时的作用域。</li><li>全局作用域。</li></ol><p>闭包常见用途：</p><ol><li>创建特权方法用于访问控制</li><li>事件处理程序及回调</li></ol><h3 id="javascript-有哪几种方法定义函数">javascript 有哪几种方法定义函数</h3><ol><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function">函数声明表达式</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function">function 操作符</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function">Function 构造函数</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/arrow_functions">ES6:arrow function</a></li></ol><p>重要参考资料：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope">MDN:Functions_and_function_scope</a></p><h3 id="应用程序存储和离线-web-应用">应用程序存储和离线 web 应用</h3><p>HTML5 新增应用程序缓存，允许 web 应用将应用程序自身保存到用户浏览器中，用户离线状态也能访问。 1.为 html 元素设置 manifest 属性:<code>&lt;html manifest=&quot;myapp.appcache&quot;&gt;</code>，其中后缀名只是一个约定，真正识别方式是通过<code>text/cache-manifest</code>作为 MIME 类型。所以需要配置服务器保证设置正确 2.manifest 文件首行为<code>CACHE MANIFEST</code>，其余就是要缓存的 URL 列表，每个一行，相对路径都相对于 manifest 文件的 url。注释以#开头 3.url 分为三种类型：<code>CACHE</code>:为默认类型。<code>NETWORK</code>：表示资源从不缓存。 <code>FALLBACK</code>:每行包含两个 url，第二个 URL 是指需要加载和存储在缓存中的资源， 第一个 URL 是一个前缀。任何匹配该前缀的 URL 都不会缓存，如果从网络中载入这样的 URL 失败的话，就会用第二个 URL 指定的缓存资源来替代。以下是一个文件例子：</p><pre><code>CACHE MANIFEST

CACHE:
myapp.html
myapp.css
myapp.js

FALLBACK:
videos/ offline_help.html

NETWORK:
cgi/
</code></pre><h3 id="客户端存储-localstorage-和-sessionstorage">客户端存储 localStorage 和 sessionStorage</h3><ul><li>localStorage 有效期为永久，sessionStorage 有效期为顶层窗口关闭前</li><li>同源文档可以读取并修改 localStorage 数据，sessionStorage 只允许同一个窗口下的文档访问，如通过 iframe 引入的同源文档。</li><li>Storage 对象通常被当做普通 javascript 对象使用：<strong>通过设置属性来存取字符串值</strong>，也可以通过<strong>setItem(key, value)设置</strong>，<strong>getItem(key)读取</strong>，<strong>removeItem(key)删除</strong>，<strong>clear()删除所有数据</strong>，<strong>length 表示已存储的数据项数目</strong>，<strong>key(index)返回对应索引的 key</strong></li></ul><pre><code>localStorage.setItem('x', 1); // storge x-&gt;1
localStorage.getItem('x); // return value of x

// 枚举所有存储的键值对
for (var i = 0, len = localStorage.length; i &lt; len; ++i ) {
    var name = localStorage.key(i);
    var value = localStorage.getItem(name);
}

localStorage.removeItem('x'); // remove x
localStorage.clear();  // remove all data
</code></pre><h3 id="cookie-及其操作">cookie 及其操作</h3><ul><li>cookie 是 web 浏览器存储的少量数据，最早设计为服务器端使用，作为 HTTP 协议的扩展实现。cookie 数据会自动在浏览器和服务器之间传输。</li><li>通过读写 cookie 检测是否支持</li><li>cookie 属性有<strong>名</strong>，<strong>值</strong>，<strong>max-age</strong>，<strong>path</strong>, <strong>domain</strong>，<strong>secure</strong>；</li><li>cookie 默认有效期为浏览器会话，一旦用户关闭浏览器，数据就丢失，通过设置<strong>max-age=seconds</strong>属性告诉浏览器 cookie 有效期</li><li>cookie 作用域通过<strong>文档源</strong>和<strong>文档路径</strong>来确定，通过<strong>path</strong>和<strong>domain</strong>进行配置，web 页面同目录或子目录文档都可访问</li><li>通过 cookie 保存数据的方法为：为 document.cookie 设置一个符合目标的字符串如下</li><li>读取 document.cookie 获得&rsquo;; &lsquo;分隔的字符串，key=value,解析得到结果</li></ul><pre><code>document.cookie = 'name=qiu; max-age=9999; path=/; domain=domain; secure';

document.cookie = 'name=aaa; path=/; domain=domain; secure';
// 要改变cookie的值，需要使用相同的名字、路径和域，新的值
// 来设置cookie，同样的方法可以用来改变有效期

// 设置max-age为0可以删除指定cookie

//读取cookie，访问document.cookie返回键值对组成的字符串，
//不同键值对之间用'; '分隔。通过解析获得需要的值
</code></pre><p><a href="https://github.com/qiu-deqing/google/blob/master/module/js/cookieUtil.js">cookieUtil.js</a>：自己写的 cookie 操作工具</p><h3 id="javascript-有哪些方法定义对象">javascript 有哪些方法定义对象</h3><ol><li>对象字面量： <code>var obj = {};</code></li><li>构造函数： <code>var obj = new Object();</code></li><li>Object.create(): <code>var obj = Object.create(Object.prototype);</code></li></ol><h3 id="运算符判断相等的流程是怎样的">===运算符判断相等的流程是怎样的</h3><ol><li>如果两个值不是相同类型，它们不相等</li><li>如果两个值都是 null 或者都是 undefined，它们相等</li><li>如果两个值都是布尔类型 true 或者都是 false，它们相等</li><li>如果其中有一个是<strong>NaN</strong>，它们不相等</li><li>如果都是数值型并且数值相等，他们相等， -0 等于 0</li><li>如果他们都是字符串并且在相同位置包含相同的 16 位值，他它们相等；如果在长度或者内容上不等，它们不相等；两个字符串显示结果相同但是编码不同==和===都认为他们不相等</li><li>如果他们指向相同对象、数组、函数，它们相等；如果指向不同对象，他们不相等</li></ol><h3 id="运算符判断相等的流程是怎样的-1">==运算符判断相等的流程是怎样的</h3><ol><li>如果两个值类型相同，按照===比较方法进行比较</li><li>如果类型不同，使用如下规则进行比较</li><li>如果其中一个值是 null，另一个是 undefined，它们相等</li><li>如果一个值是<strong>数字</strong>另一个是<strong>字符串</strong>，将<strong>字符串转换为数字</strong>进行比较</li><li>如果有布尔类型，将<strong>true 转换为 1，false 转换为 0</strong>，然后用==规则继续比较</li><li>如果一个值是对象，另一个是数字或字符串，将对象转换为原始值然后用==规则继续比较</li><li><strong>其他所有情况都认为不相等</strong></li></ol><h3 id="对象到字符串的转换步骤">对象到字符串的转换步骤</h3><ol><li>如果对象有 toString()方法，javascript 调用它。如果返回一个原始值（primitive value 如：string number boolean）,将这个值转换为字符串作为结果</li><li>如果对象没有 toString()方法或者返回值不是原始值，javascript 寻找对象的 valueOf()方法，如果存在就调用它，返回结果是原始值则转为字符串作为结果</li><li>否则，javascript 不能从 toString()或者 valueOf()获得一个原始值，此时 throws a TypeError</li></ol><h3 id="对象到数字的转换步骤">对象到数字的转换步骤</h3><pre><code>1. 如果对象有valueOf()方法并且返回元素值，javascript将返回值转换为数字作为结果
2. 否则，如果对象有toString()并且返回原始值，javascript将返回结果转换为数字作为结果
3. 否则，throws a TypeError
</code></pre><h3 id="的比较规则">&lt;,&gt;,&lt;=,&gt;=的比较规则</h3><p>所有比较运算符都支持任意类型，但是<strong>比较只支持数字和字符串</strong>，所以需要执行必要的转换然后进行比较，转换规则如下:</p><ol><li>如果操作数是对象，转换为原始值：如果 valueOf 方法返回原始值，则使用这个值，否则使用 toString 方法的结果，如果转换失败则报错</li><li>经过必要的对象到原始值的转换后，如果两个操作数都是字符串，按照字母顺序进行比较（他们的 16 位 unicode 值的大小）</li><li>否则，如果有一个操作数不是字符串，<strong>将两个操作数转换为数字</strong>进行比较</li></ol><h3 id="运算符工作流程">+运算符工作流程</h3><ol><li>如果有操作数是对象，转换为原始值</li><li>此时如果有<strong>一个操作数是字符串</strong>，其他的操作数都转换为字符串并执行连接</li><li>否则：<strong>所有操作数都转换为数字并执行加法</strong></li></ol><h3 id="函数内部-arguments-变量有哪些特性-有哪些属性-如何将它转换为数组">函数内部 arguments 变量有哪些特性,有哪些属性,如何将它转换为数组</h3><ul><li>arguments 所有函数中都包含的一个局部变量，是一个类数组对象，对应函数调用时的实参。如果函数定义同名参数会在调用时覆盖默认对象</li><li>arguments[index]分别对应函数调用时的实参，并且通过 arguments 修改实参时会同时修改实参</li><li>arguments.length 为实参的个数（Function.length 表示形参长度）</li><li>arguments.callee 为当前正在执行的函数本身，使用这个属性进行递归调用时需注意 this 的变化</li><li>arguments.caller 为调用当前函数的函数（已被遗弃）</li><li>转换为数组：<code>var args = Array.prototype.slice.call(arguments, 0);</code></li></ul><h3 id="dom-事件模型是如何的-编写一个-eventutil-工具类实现事件管理兼容">DOM 事件模型是如何的,编写一个 EventUtil 工具类实现事件管理兼容</h3><ul><li>DOM 事件包含捕获（capture）和冒泡（bubble）两个阶段：捕获阶段事件从 window 开始触发事件然后通过祖先节点一次传递到触发事件的 DOM 元素上；冒泡阶段事件从初始元素依次向祖先节点传递直到 window</li><li>标准事件监听 elem.addEventListener(type, handler, capture)/elem.removeEventListener(type, handler, capture)：handler 接收保存事件信息的 event 对象作为参数，event.target 为触发事件的对象，handler 调用上下文 this 为绑定监听器的对象，event.preventDefault()取消事件默认行为，event.stopPropagation()/event.stopImmediatePropagation()取消事件传递</li><li>老版本 IE 事件监听 elem.attachEvent(&lsquo;on&rsquo;+type, handler)/elem.detachEvent(&lsquo;on&rsquo;+type, handler)：handler 不接收 event 作为参数，事件信息保存在 window.event 中，触发事件的对象为 event.srcElement，handler 执行上下文 this 为 window 使用闭包中调用 handler.call(elem, event)可模仿标准模型，然后返回闭包，保证了监听器的移除。event.returnValue 为 false 时取消事件默认行为，event.cancleBubble 为 true 时取消时间传播</li><li>通常利用事件冒泡机制托管事件处理程序提高程序性能。</li></ul><pre><code>/**
 * 跨浏览器事件处理工具。只支持冒泡。不支持捕获
 * @author  (qiu_deqing@126.com)
 */

var EventUtil = {
    getEvent: function (event) {
        return event || window.event;
    },
    getTarget: function (event) {
        return event.target || event.srcElement;
    },
    // 返回注册成功的监听器，IE中需要使用返回值来移除监听器
    on: function (elem, type, handler) {
        if (elem.addEventListener) {
            elem.addEventListener(type, handler, false);
            return handler;
        } else if (elem.attachEvent) {
            var wrapper = function () {
              var event = window.event;
              event.target = event.srcElement;
              handler.call(elem, event);
            };
            elem.attachEvent('on' + type, wrapper);
            return wrapper;
        }
    },
    off: function (elem, type, handler) {
        if (elem.removeEventListener) {
            elem.removeEventListener(type, handler, false);
        } else if (elem.detachEvent) {
            elem.detachEvent('on' + type, handler);
        }
    },
    preventDefault: function (event) {
        if (event.preventDefault) {
            event.preventDefault();
        } else if ('returnValue' in event) {
            event.returnValue = false;
        }
    },
    stopPropagation: function (event) {
        if (event.stopPropagation) {
            event.stopPropagation();
        } else if ('cancelBubble' in event) {
            event.cancelBubble = true;
        }
    },
    /**
     * keypress事件跨浏览器获取输入字符
     * 某些浏览器在一些特殊键上也触发keypress，此时返回null
     **/
     getChar: function (event) {
        if (event.which == null) {
            return String.fromCharCode(event.keyCode);  // IE
        }
        else if (event.which != 0 &amp;&amp; event.charCode != 0) {
            return String.fromCharCode(event.which);    // the rest
        }
        else {
            return null;    // special key
        }
     }
};
</code></pre><h3 id="评价一下三种方法实现继承的优缺点-并改进">评价一下三种方法实现继承的优缺点,并改进</h3><pre><code>function Shape() {}

function Rect() {}

// 方法1
Rect.prototype = new Shape();

// 方法2
Rect.prototype = Shape.prototype;

// 方法3
Rect.prototype = Object.create(Shape.prototype);

Rect.prototype.area = function () {
  // do something
};
</code></pre><p>方法 1：</p><ol><li>优点：正确设置原型链实现继承</li><li>优点：父类实例属性得到继承，原型链查找效率提高，也能为一些属性提供合理的默认值</li><li>缺点：父类实例属性为引用类型时，不恰当地修改会导致所有子类被修改</li><li>缺点：创建父类实例作为子类原型时，可能无法确定构造函数需要的合理参数，这样提供的参数继承给子类没有实际意义，当子类需要这些参数时应该在构造函数中进行初始化和设置</li><li>总结：继承应该是继承方法而不是属性，为子类设置父类实例属性应该是通过在子类构造函数中调用父类构造函数进行初始化</li></ol><p>方法 2：</p><ol><li>优点：正确设置原型链实现继承</li><li>缺点：父类构造函数原型与子类相同。修改子类原型添加方法会修改父类</li></ol><p>方法 3：</p><ol><li>优点：正确设置原型链且避免方法 1.2 中的缺点</li><li>缺点：ES5 方法需要注意兼容性</li></ol><p>改进：</p><ol><li>所有三种方法应该在子类构造函数中调用父类构造函数实现实例属性初始化</li></ol><pre><code>function Rect() {
    Shape.call(this);
}
</code></pre><ol><li>用新创建的对象替代子类默认原型，设置<code>Rect.prototype.constructor = Rect;</code>保证一致性</li><li>第三种方法的 polyfill：</li></ol><pre><code>function create(obj) {
    if (Object.create) {
        return Object.create(obj);
    }

    function f() {};
    f.prototype = obj;
    return new f();
}
</code></pre><h2 id="javascript-编程部分">$javascript 编程部分</h2><h3 id="请用原生-js-实现一个函数-给页面制定的任意一个元素添加一个透明遮罩-透明度可变-默认-0-2-使这个区域点击无效-要求兼容-ie8-及各主流浏览器-遮罩层效果如下图所示">请用原生 js 实现一个函数,给页面制定的任意一个元素添加一个透明遮罩(透明度可变,默认 0.2),使这个区域点击无效,要求兼容 IE8+及各主流浏览器,遮罩层效果如下图所示:</h3><p><img src="img/element-mask.jpg" alt="遮罩效果"></p><pre><code>&lt;style&gt;
#target {
    width: 200px;
    height: 300px;
    margin: 40px;
    background-color: tomato;
}
&lt;/style&gt;

&lt;div id=&quot;target&quot;&gt;&lt;/div&gt;

&lt;script&gt;
function addMask(elem, opacity) {
    opacity = opacity || 0.2;

    var rect = elem.getBoundingClientRect();
    var style = getComputedStyle(elem, null);

    var mask = document.createElement('div');
    mask.style.position = 'absolute';
    var marginLeft = parseFloat(style.marginLeft);
    mask.style.left = (elem.offsetLeft - marginLeft) + 'px';
    var marginTop = parseFloat(style.marginTop);
    mask.style.top = (elem.offsetTop - marginTop) + 'px';
    mask.style.zIndex = 9999;
    mask.style.opacity = '' + opacity;
    mask.style.backgroundColor = '#000';

    mask.style.width = (parseFloat(style.marginLeft) +
        parseFloat(style.marginRight) + rect.width) + 'px';
    mask.style.height = (parseFloat(style.marginTop) +
        parseFloat(style.marginBottom) + rect.height) + 'px';

    elem.parentNode.appendChild(mask);
}

var target = document.getElementById('target');
addMask(target);

target.addEventListener('click', function () {
    console.log('click');
}, false);
&lt;/script&gt;
</code></pre><h3 id="请用代码写出-今天是星期-x-其中-x-表示当天是星期几-如果当天是星期一-输出应该是-今天是星期一">请用代码写出(今天是星期 x)其中 x 表示当天是星期几,如果当天是星期一,输出应该是&rdquo;今天是星期一&rdquo;</h3><pre><code>var days = ['日','一','二','三','四','五','六'];
var date = new Date();

console.log('今天是星期' + days[date.getDay()]);
</code></pre><h3 id="下面这段代码想要循环延时输出结果-0-1-2-3-4-请问输出结果是否正确-如果不正确-请说明为什么-并修改循环内的代码使其输出正确结果">下面这段代码想要循环延时输出结果 0 1 2 3 4,请问输出结果是否正确,如果不正确,请说明为什么,并修改循环内的代码使其输出正确结果</h3><pre><code>for (var i = 0; i &lt; 5; ++i) {
  setTimeout(function () {
    console.log(i + ' ');
  }, 100);
}
</code></pre><p>不能输出正确结果，因为循环中 setTimeout 接受的参数函数通过闭包访问变量 i。javascript 运行环境为单线程，setTimeout 注册的函数需要等待线程空闲才能执行，此时 for 循环已经结束，i 值为 5.五个定时输出都是 5 修改方法：将 setTimeout 放在函数立即调用表达式中，将 i 值作为参数传递给包裹函数，创建新闭包</p><pre><code>for (var i = 0; i &lt; 5; ++i) {
  (function (i) {
    setTimeout(function () {
      console.log(i + ' ');
    }, 100);
  }(i));
}
</code></pre><h3 id="现有一个-page-类-其原型对象上有许多以-post-开头的方法-如-postmsg-另有一拦截函数-chekc-只返回-ture-或-false-请设计一个函数-该函数应批量改造原-page-的-postxxx-方法-在保留其原有功能的同时-为每个-postxxx-方法增加拦截验证功能-当-chekc-返回-true-时继续执行原-postxxx-方法-返回-false-时不再执行原-postxxx-方法">现有一个 Page 类,其原型对象上有许多以 post 开头的方法(如 postMsg);另有一拦截函数 chekc,只返回 ture 或 false.请设计一个函数,该函数应批量改造原 Page 的 postXXX 方法,在保留其原有功能的同时,为每个 postXXX 方法增加拦截验证功能,当 chekc 返回 true 时继续执行原 postXXX 方法,返回 false 时不再执行原 postXXX 方法</h3><pre><code>function Page() {}

Page.prototype = {
  constructor: Page,

  postA: function (a) {
    console.log('a:' + a);
  },
  postB: function (b) {
    console.log('b:' + b);
  },
  postC: function (c) {
    console.log('c:' + c);
  },
  check: function () {
    return Math.random() &gt; 0.5;
  }
}

function checkfy(obj) {
  for (var key in obj) {
    if (key.indexOf('post') === 0 &amp;&amp; typeof obj[key] === 'function') {
      (function (key) {
        var fn = obj[key];
        obj[key] = function () {
          if (obj.check()) {
            fn.apply(obj, arguments);
          }
        };
      }(key));
    }
  }
} // end checkfy()

checkfy(Page.prototype);

var obj = new Page();

obj.postA('checkfy');
obj.postB('checkfy');
obj.postC('checkfy');
</code></pre><h3 id="完成下面的-tool-tip">完成下面的 tool-tip</h3><p><img src="img/tip-box.jpg" alt="xxx"></p><h3 id="编写-javascript-深度克隆函数-deepclone">编写 javascript 深度克隆函数 deepClone</h3><pre><code>function deepClone(obj) {
    var _toString = Object.prototype.toString;

    // null, undefined, non-object, function
    if (!obj || typeof obj !== 'object') {
        return obj;
    }

    // DOM Node
    if (obj.nodeType &amp;&amp; 'cloneNode' in obj) {
        return obj.cloneNode(true);
    }

    // Date
    if (_toString.call(obj) === '[object Date]') {
        return new Date(obj.getTime());
    }

    // RegExp
    if (_toString.call(obj) === '[object RegExp]') {
        var flags = [];
        if (obj.global) { flags.push('g'); }
        if (obj.multiline) { flags.push('m'); }
        if (obj.ignoreCase) { flags.push('i'); }

        return new RegExp(obj.source, flags.join(''));
    }

    var result = Array.isArray(obj) ? [] :
        obj.constructor ? new obj.constructor() : {};

    for (var key in obj ) {
        result[key] = deepClone(obj[key]);
    }

    return result;
}

function A() {
    this.a = a;
}

var a = {
    name: 'qiu',
    birth: new Date(),
    pattern: /qiu/gim,
    container: document.body,
    hobbys: ['book', new Date(), /aaa/gim, 111]
};

var c = new A();
var b = deepClone(c);
console.log(c.a === b.a);
console.log(c, b);
</code></pre><h3 id="补充代码-鼠标单击-button1-后将-button1-移动到-button2-的后面">补充代码,鼠标单击 Button1 后将 Button1 移动到 Button2 的后面</h3><pre><code>&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;TEst&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div&gt;
   &lt;input type=&quot;button&quot; id =&quot;button1&quot; value=&quot;1&quot; /&gt;
   &lt;input type=&quot;button&quot; id =&quot;button2&quot; value=&quot;2&quot; /&gt;
&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    var btn1 = document.getElementById('button1');
    var btn2 = document.getElementById('button2');

    addListener(btn1, 'click', function (event) {
        btn1.parentNode.insertBefore(btn2, btn1);
    });

    function addListener(elem, type, handler) {
        if (elem.addEventListener) {
            elem.addEventListener(type, handler, false);
            return handler;
        } else if (elem.attachEvent) {
            function wrapper() {
                var event = window.event;
                event.target = event.srcElement;
                handler.call(elem, event);
            }
            elem.attachEvent('on' + type, wrapper);
            return wrapper;
        }
    }

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h3 id="网页中实现一个计算当年还剩多少时间的倒数计时程序-要求网页上实时动态显示-年还剩-天-时-分-秒">网页中实现一个计算当年还剩多少时间的倒数计时程序,要求网页上实时动态显示&rdquo;×× 年还剩 ×× 天 ×× 时 ×× 分 ×× 秒&rdquo;</h3><pre><code>&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;TEst&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

    &lt;span id=&quot;target&quot;&gt;&lt;/span&gt;


&lt;script type=&quot;text/javascript&quot;&gt;
    // 为了简化。每月默认30天
    function getTimeString() {
        var start = new Date();
        var end = new Date(start.getFullYear() + 1, 0, 1);
        var elapse = Math.floor((end - start) / 1000);

        var seconds = elapse % 60 ;
        var minutes = Math.floor(elapse / 60) % 60;
        var hours = Math.floor(elapse / (60 * 60)) % 24;
        var days = Math.floor(elapse / (60 * 60 * 24)) % 30;
        var months = Math.floor(elapse / (60 * 60 * 24 * 30)) % 12;
        var years = Math.floor(elapse / (60 * 60 * 24 * 30 * 12));

        return start.getFullYear() + '年还剩' + years + '年' + months + '月' + days + '日'
            + hours + '小时' + minutes + '分' + seconds + '秒';
    }

    function domText(elem, text) {
        if (text == undefined) {

            if (elem.textContent) {
                return elem.textContent;
            } else if (elem.innerText) {
                return elem.innerText;
            }
        } else {
            if (elem.textContent) {
                elem.textContent = text;
            } else if (elem.innerText) {
                elem.innerText = text;
            } else {
                elem.innerHTML = text;
            }
        }
    }

    var target = document.getElementById('target');

    setInterval(function () {
        domText(target, getTimeString());
    }, 1000)
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre><h3 id="完成一个函数-接受数组作为参数-数组元素为整数或者数组-数组元素包含整数或数组-函数返回扁平化后的数组">完成一个函数,接受数组作为参数,数组元素为整数或者数组,数组元素包含整数或数组,函数返回扁平化后的数组</h3><p>如：[1, [2, [ [3, 4], 5], 6]] =&gt; [1, 2, 3, 4, 5, 6]</p><pre><code>    var data =  [1, [2, [ [3, 4], 5], 6]];

    function flat(data, result) {
        var i, d, len;
        for (i = 0, len = data.length; i &lt; len; ++i) {
            d = data[i];
            if (typeof d === 'number') {
                result.push(d);
            } else {
                flat(d, result);
            }
        }
    }

    var result = [];
    flat(data, result);

    console.log(result);
</code></pre><h3 id="如何判断一个对象是否为数组">如何判断一个对象是否为数组</h3><p>如果浏览器支持 Array.isArray()可以直接判断否则需进行必要判断</p><pre><code>/**
 * 判断一个对象是否是数组，参数不是对象或者不是数组，返回false
 *
 * @param {Object} arg 需要测试是否为数组的对象
 * @return {Boolean} 传入参数是数组返回true，否则返回false
 */
function isArray(arg) {
    if (typeof arg === 'object') {
        return Object.prototype.toString.call(arg) === '[object Array]';
    }
    return false;
}
</code></pre><h3 id="请评价以下事件监听器代码并给出改进意见">请评价以下事件监听器代码并给出改进意见</h3><pre><code>if (window.addEventListener) {
  var addListener = function (el, type, listener, useCapture) {
    el.addEventListener(type, listener, useCapture);
  };
}
else if (document.all) {
  addListener = function (el, type, listener) {
    el.attachEvent('on' + type, function () {
      listener.apply(el);
    });
  };
}
</code></pre><p>作用：浏览器功能检测实现跨浏览器 DOM 事件绑定</p><p>优点：</p><ol><li>测试代码只运行一次，根据浏览器确定绑定方法</li><li>通过<code>listener.apply(el)</code>解决 IE 下监听器 this 与标准不一致的地方</li><li>在浏览器不支持的情况下提供简单的功能，在标准浏览器中提供捕获功能</li></ol><p>缺点：</p><ol><li>document.all 作为 IE 检测不可靠，应该使用 if(el.attachEvent)</li><li>addListener 在不同浏览器下 API 不一样</li><li><code>listener.apply</code>使 this 与标准一致但监听器无法移除</li><li>未解决 IE 下 listener 参数 event。 target 问题</li></ol><p>改进:</p><pre><code>var addListener;

if (window.addEventListener) {
  addListener = function (el, type, listener, useCapture) {
    el.addEventListener(type, listener, useCapture);
    return listener;
  };
}
else if (window.attachEvent) {
  addListener = function (el, type, listener) {
    // 标准化this，event，target
    var wrapper = function () {
      var event = window.event;
      event.target = event.srcElement;
      listener.call(el, event);
    };

    el.attachEvent('on' + type, wrapper);
    return wrapper;
    // 返回wrapper。调用者可以保存，以后remove
  };
}
</code></pre><h3 id="如何判断一个对象是否为函数">如何判断一个对象是否为函数</h3><pre><code>/**
 * 判断对象是否为函数，如果当前运行环境对可调用对象（如正则表达式）
 * 的typeof返回'function'，采用通用方法，否则采用优化方法
 *
 * @param {Any} arg 需要检测是否为函数的对象
 * @return {boolean} 如果参数是函数，返回true，否则false
 */
function isFunction(arg) {
    if (arg) {
        if (typeof (/./) !== 'function') {
            return typeof arg === 'function';
        } else {
            return Object.prototype.toString.call(arg) === '[object Function]';
        }
    } // end if
    return false;
}
</code></pre><h3 id="编写一个函数接受-url-中-query-string-为参数-返回解析后的-object-query-string-使用-application-x-www-form-urlencoded-编码">编写一个函数接受 url 中 query string 为参数,返回解析后的 Object,query string 使用 application/x-www-form-urlencoded 编码</h3><pre><code>/**
 * 解析query string转换为对象，一个key有多个值时生成数组
 *
 * @param {String} query 需要解析的query字符串，开头可以是?，
 * 按照application/x-www-form-urlencoded编码
 * @return {Object} 参数解析后的对象
 */
function parseQuery(query) {
    var result = {};

    // 如果不是字符串返回空对象
    if (typeof query !== 'string') {
        return result;
    }

    // 去掉字符串开头可能带的?
    if (query.charAt(0) === '?') {
        query = query.substring(1);
    }

    var pairs = query.split('&amp;');
    var pair;
    var key, value;
    var i, len;

    for (i = 0, len = pairs.length; i &lt; len; ++i) {
        pair = pairs[i].split('=');
        // application/x-www-form-urlencoded编码会将' '转换为+
        key = decodeURIComponent(pair[0]).replace(/\+/g, ' ');
        value = decodeURIComponent(pair[1]).replace(/\+/g, ' ');

        // 如果是新key，直接添加
        if (!(key in result)) {
            result[key] = value;
        }
        // 如果key已经出现一次以上，直接向数组添加value
        else if (isArray(result[key])) {
            result[key].push(value);
        }
        // key第二次出现，将结果改为数组
        else {
            var arr = [result[key]];
            arr.push(value);
            result[key] = arr;
        } // end if-else
    } // end for

    return result;
}

function isArray(arg) {
    if (arg &amp;&amp; typeof arg === 'object') {
        return Object.prototype.toString.call(arg) === '[object Array]';
    }
    return false;
}
/**
console.log(parseQuery('sourceid=chrome-instant&amp;ion=1&amp;espv=2&amp;ie=UTF-8'));
 */
</code></pre><h3 id="解析一个完整的-url-返回-object-包含域与-window-location-相同">解析一个完整的 url,返回 Object 包含域与 window.location 相同</h3><pre><code>/**
 * 解析一个url并生成window.location对象中包含的域
 * location:
 * {
 *      href: '包含完整的url',
 *      origin: '包含协议到pathname之前的内容',
 *      protocol: 'url使用的协议，包含末尾的:',
 *      username: '用户名', // 暂时不支持
 *      password: '密码',  // 暂时不支持
 *      host: '完整主机名，包含:和端口',
 *      hostname: '主机名，不包含端口'
 *      port: '端口号',
 *      pathname: '服务器上访问资源的路径/开头',
 *      search: 'query string，?开头',
 *      hash: '#开头的fragment identifier'
 * }
 *
 * @param {string} url 需要解析的url
 * @return {Object} 包含url信息的对象
 */
function parseUrl(url) {
    var result = {};
    var keys = ['href', 'origin', 'protocol', 'host',
                'hostname', 'port', 'pathname', 'search', 'hash'];
    var i, len;
    var regexp = /(([^:]+:)\/\/(([^:\/\?#]+)(:\d+)?))(\/[^?#]*)?(\?[^#]*)?(#.*)?/;

    var match = regexp.exec(url);

    if (match) {
        for (i = keys.length - 1; i &gt;= 0; --i) {
            result[keys[i]] = match[i] ? match[i] : '';
        }
    }

    return result;
}
</code></pre><h3 id="完成函数-getviewportsize-返回指定窗口的视口尺寸">完成函数 getViewportSize 返回指定窗口的视口尺寸</h3><pre><code>/**
* 查询指定窗口的视口尺寸，如果不指定窗口，查询当前窗口尺寸
**/
function getViewportSize(w) {
    w = w || window;

    // IE9及标准浏览器中可使用此标准方法
    if ('innerHeight' in w) {
        return {
            width: w.innerWidth,
            height: w.innerHeight
        };
    }

    var d = w.document;
    // IE 8及以下浏览器在标准模式下
    if (document.compatMode === 'CSS1Compat') {
        return {
            width: d.documentElement.clientWidth,
            height: d.documentElement.clientHeight
        };
    }

    // IE8及以下浏览器在怪癖模式下
    return {
        width: d.body.clientWidth,
        height: d.body.clientHeight
    };
}
</code></pre><h3 id="完成函数-getscrolloffset-返回窗口滚动条偏移量">完成函数 getScrollOffset 返回窗口滚动条偏移量</h3><pre><code>/**
 * 获取指定window中滚动条的偏移量，如未指定则获取当前window
 * 滚动条偏移量
 *
 * @param {window} w 需要获取滚动条偏移量的窗口
 * @return {Object} obj.x为水平滚动条偏移量,obj.y为竖直滚动条偏移量
 */
function getScrollOffset(w) {
    w =  w || window;
    // 如果是标准浏览器
    if (w.pageXOffset != null) {
        return {
            x: w.pageXOffset,
            y: w.pageYOffset
        };
    }

    // 老版本IE，根据兼容性不同访问不同元素
    var d = w.document;
    if (d.compatMode === 'CSS1Compat') {
        return {
            x: d.documentElement.scrollLeft,
            y: d.documentElement.scrollTop
        }
    }

    return {
        x: d.body.scrollLeft,
        y: d.body.scrollTop
    };
}
</code></pre><h3 id="现有一个字符串-richtext-是一段富文本-需要显示在页面上-有个要求-需要给其中只包含一个-img-元素的-p-标签增加一个叫-pic-的-class-请编写代码实现-可以使用-jquery-或-kissy">现有一个字符串 richText,是一段富文本,需要显示在页面上.有个要求,需要给其中只包含一个 img 元素的 p 标签增加一个叫 pic 的 class.请编写代码实现.可以使用 jQuery 或 KISSY.</h3><pre><code>function richText(text) {
    var div = document.createElement('div');
    div.innerHTML = text;
    var p = div.getElementsByTagName('p');
    var i, len;

    for (i = 0, len = p.length; i &lt; len; ++i) {
        if (p[i].getElementsByTagName('img').length === 1) {
            p[i].classList.add('pic');
        }
    }

    return div.innerHTML;
}
</code></pre><h3 id="请实现一个-event-类-继承自此类的对象都会拥有两个方法-on-off-once-和-trigger">请实现一个 Event 类,继承自此类的对象都会拥有两个方法 on,off,once 和 trigger</h3><pre><code>function Event() {
    if (!(this instanceof Event)) {
        return new Event();
    }
    this._callbacks = {};
}
Event.prototype.on = function (type, handler) {
    this_callbacks = this._callbacks || {};
    this._callbacks[type] = this.callbacks[type] || [];
    this._callbacks[type].push(handler);

    return this;
};

Event.prototype.off = function (type, handler) {
    var list = this._callbacks[type];

    if (list) {
        for (var i = list.length; i &gt;= 0; --i) {
            if (list[i] === handler) {
                list.splice(i, 1);
            }
        }
    }

    return this;
};

Event.prototype.trigger = function (type, data) {
    var list = this._callbacks[type];

    if (list) {
        for (var i = 0, len = list.length; i &lt; len; ++i) {
            list[i].call(this, data);
        }
    }
};

Event.prototype.once = function (type, handler) {
    var self = this;

    function wrapper() {
        handler.apply(self, arguments);
        self.off(type, wrapper);
    }
    this.on(type, wrapper);
    return this;
};
</code></pre><h3 id="编写一个函数将列表子元素顺序反转">编写一个函数将列表子元素顺序反转</h3><pre><code>&lt;ul id=&quot;target&quot;&gt;
    &lt;li&gt;1&lt;/li&gt;
    &lt;li&gt;2&lt;/li&gt;
    &lt;li&gt;3&lt;/li&gt;
    &lt;li&gt;4&lt;/li&gt;
&lt;/ul&gt;

&lt;script&gt;
    var target = document.getElementById('target');
    var i;
    var frag = document.createDocumentFragment();

    for (i = target.children.length - 1; i &amp;gt;= 0; --i) {
        frag.appendChild(target.children[i]);
    }
    target.appendChild(frag);
&lt;/script&gt;
</code></pre><h3 id="以下函数的作用是-空白区域应该填写什么">以下函数的作用是?空白区域应该填写什么</h3><pre><code>// define
(function (window) {
    function fn(str) {
        this.str = str;
    }

    fn.prototype.format = function () {
        var arg = __1__;
        return this.str.replace(__2__, function (a, b) {
            return arg[b] || '';
        });
    };

    window.fn = fn;
})(window);

// use
(function () {
    var t = new fn('&lt;p&gt;&lt;a href=&quot;{0}&quot;&gt;{1}&lt;/a&gt;&lt;span&gt;{2}&lt;/span&gt;&lt;/p&gt;');
    console.log(t.format('http://www.alibaba.com', 'Alibaba', 'Welcome'));
})();
</code></pre><p>define 部分定义一个简单的模板类，使用{}作为转义标记，中间的数字表示替换目标，format 实参用来替换模板内标记 横线处填：</p><ol><li><code>Array.prototype.slice.call(arguments, 0)</code></li><li><code>/\{\s*(\d+)\s*\}/g</code></li></ol><h3 id="编写一个函数实现-form-的序列化-即将一个表单中的键值序列化为可提交的字符串">编写一个函数实现 form 的序列化(即将一个表单中的键值序列化为可提交的字符串)</h3><pre><code>&lt;form id=&quot;target&quot;&gt;
    &lt;select name=&quot;age&quot;&gt;
        &lt;option value=&quot;aaa&quot;&gt;aaa&lt;/option&gt;
        &lt;option value=&quot;bbb&quot; selected&gt;bbb&lt;/option&gt;
    &lt;/select&gt;
    &lt;select name=&quot;friends&quot; multiple&gt;
        &lt;option value=&quot;qiu&quot; selected&gt;qiu&lt;/option&gt;
        &lt;option value=&quot;de&quot;&gt;de&lt;/option&gt;
        &lt;option value=&quot;qing&quot; selected&gt;qing&lt;/option&gt;
    &lt;/select&gt;
    &lt;input name=&quot;name&quot; value=&quot;qiudeqing&quot;&gt;
    &lt;input type=&quot;password&quot; name=&quot;password&quot; value=&quot;11111&quot;&gt;
    &lt;input type=&quot;hidden&quot; name=&quot;salery&quot; value=&quot;3333&quot;&gt;
    &lt;textarea name=&quot;description&quot;&gt;description&lt;/textarea&gt;
    &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; checked value=&quot;football&quot;&gt;Football
    &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;basketball&quot;&gt;Basketball
    &lt;input type=&quot;radio&quot; name=&quot;sex&quot; checked value=&quot;Female&quot;&gt;Female
    &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;Male&quot;&gt;Male
&lt;/form&gt;


&lt;script&gt;

/**
 * 将一个表单元素序列化为可提交的字符串
 *
 * @param {FormElement} form 需要序列化的表单元素
 * @return {string} 表单序列化后的字符串
 */
function serializeForm(form) {
  if (!form || form.nodeName.toUpperCase() !== 'FORM') {
    return;
  }

  var result = [];

  var i, len;
  var field, fieldName, fieldType;

  for (i = 0, len = form.length; i &lt; len; ++i) {
    field = form.elements[i];
    fieldName = field.name;
    fieldType = field.type;

    if (field.disabled || !fieldName) {
      continue;
    } // enf if

    switch (fieldType) {
      case 'text':
      case 'password':
      case 'hidden':
      case 'textarea':
        result.push(encodeURIComponent(fieldName) + '=' +
            encodeURIComponent(field.value));
        break;

      case 'radio':
      case 'checkbox':
        if (field.checked) {
          result.push(encodeURIComponent(fieldName) + '=' +
            encodeURIComponent(field.value));
        }
        break;

      case 'select-one':
      case 'select-multiple':
        for (var j = 0, jLen = field.options.length; j &lt; jLen; ++j) {
          if (field.options[j].selected) {
            result.push(encodeURIComponent(fieldName) + '=' +
              encodeURIComponent(field.options[j].value || field.options[j].text));
          }
        } // end for
        break;

      case 'file':
      case 'submit':
        break; // 是否处理？

      default:
        break;
    } // end switch
  } // end for

    return result.join('&amp;');
}

var form = document.getElementById('target');
console.log(serializeForm(form));
&lt;/script&gt;
</code></pre><h3 id="使用原生-javascript-给下面列表中的-li-节点绑定点击事件-点击时创建一个-object-对象-兼容-ie-和标准浏览器">使用原生 javascript 给下面列表中的 li 节点绑定点击事件,点击时创建一个 Object 对象,兼容 IE 和标准浏览器</h3><pre><code>&lt;ul id=&quot;nav&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;http://11111&quot;&gt;111&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://2222&quot;&gt;222&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://333&quot;&gt;333&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://444&quot;&gt;444&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

Object:
{
    &quot;index&quot;: 1,
    &quot;name&quot;: &quot;111&quot;,
    &quot;link&quot;: &quot;http://1111&quot;
}
</code></pre><p>script:</p><pre><code>var EventUtil = {
    getEvent: function (event) {
        return event || window.event;
    },
    getTarget: function (event) {
        return event.target || event.srcElement;
    },
    // 返回注册成功的监听器，IE中需要使用返回值来移除监听器
    on: function (elem, type, handler) {
        if (elem.addEventListener) {
            elem.addEventListener(type, handler, false);
            return handler;
        } else if (elem.attachEvent) {
            function wrapper(event) {
                return handler.call(elem, event);
            };
            elem.attachEvent('on' + type, wrapper);
            return wrapper;
        }
    },
    off: function (elem, type, handler) {
        if (elem.removeEventListener) {
            elem.removeEventListener(type, handler, false);
        } else if (elem.detachEvent) {
            elem.detachEvent('on' + type, handler);
        }
    },
    preventDefault: function (event) {
        if (event.preventDefault) {
            event.preventDefault();
        } else if ('returnValue' in event) {
            event.returnValue = false;
        }
    },
    stopPropagation: function (event) {
        if (event.stopPropagation) {
            event.stopPropagation();
        } else if ('cancelBubble' in event) {
            event.cancelBubble = true;
        }
    }
};
var DOMUtil = {
    text: function (elem) {
        if ('textContent' in elem) {
            return elem.textContent;
        } else if ('innerText' in elem) {
            return elem.innerText;
        }
    },
    prop: function (elem, propName) {
        return elem.getAttribute(propName);
    }
};

var nav = document.getElementById('nav');

EventUtil.on(nav, 'click', function (event) {
    var event = EventUtil.getEvent(event);
    var target = EventUtil.getTarget(event);

    var children = this.children;
    var i, len;
    var anchor;
    var obj = {};

    for (i = 0, len = children.length; i &lt; len; ++i) {
        if (children[i] === target) {
            obj.index = i + 1;
            anchor = target.getElementsByTagName('a')[0];
            obj.name = DOMUtil.text(anchor);
            obj.link = DOMUtil.prop(anchor, 'href');
        }
    }

    alert('index: ' + obj.index + ' name: ' + obj.name +
        ' link: ' + obj.link);
});
</code></pre><h3 id="有一个大数组-var-a-1-2-3-a-的长度是-100-内容填充随机整数的字符串-请先构造此数组-a-然后设计一个算法将其内容去重">有一个大数组,var a = [&lsquo;1&rsquo;, &lsquo;2&rsquo;, &lsquo;3&rsquo;, &hellip;];a 的长度是 100,内容填充随机整数的字符串.请先构造此数组 a,然后设计一个算法将其内容去重</h3><pre><code>    /**
    * 数组去重
    **/
    function normalize(arr) {
        if (arr &amp;&amp; Array.isArray(arr)) {
            var i, len, map = {};
            for (i = arr.length; i &gt;= 0; --i) {
                if (arr[i] in map) {
                    arr.splice(i, 1);
                } else {
                    map[arr[i]] = true;
                }
            }
        }
        return arr;
    }

    /**
    * 用100个随机整数对应的字符串填充数组。
    **/
    function fillArray(arr, start, end) {
        start = start == undefined ? 1 : start;
        end = end == undefined ?  100 : end;

        if (end &lt;= start) {
            end = start + 100;
        }

        var width = end - start;
        var i;
        for (i = 100; i &gt;= 1; --i) {
            arr.push('' + (Math.floor(Math.random() * width) + start));
        }
        return arr;
    }

    var input = [];
    fillArray(input, 1, 100);
    input.sort(function (a, b) {
        return a - b;
    });
    console.log(input);

    normalize(input);
    console.log(input);
</code></pre><p>参考资料:</p><p><a href="https://github.com/qiu-deqing/FE-interview">https://github.com/qiu-deqing/FE-interview</a></p><h2>微信公众号</h2><img src="https://incomparable9527.coding.net/p/imageBed/d/imageBed/git/raw/master/c2a91cfb597826a4b02b755746c300e00cc7728a9f5bac20bec538e8c76a443f.png"><h2>本文链接：</h2><a href="https://alili.tech/archive/7bp4sppqtsy/" target="_blank">https://alili.tech/archive/7bp4sppqtsy/</a></div></article><script src="https://cdn.bootcdn.net/ajax/libs/valine/1.4.14/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么? 证明你来过~', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><h1># 最新文章</h1><ul id="more-post-list" class="archive readmore"><li><a href="/archive/wrcvtewpsi/">我的博客即将同步至腾讯云&#43;社区<aside class="dates">2020-09-24</aside></a></li><li><a href="/archive/a8e3f4c2/">Mac系统如何关掉Chrome的跨域限制<aside class="dates">2020-09-16</aside></a></li><li><a href="/archive/97enyq3a3m/">数学篇 - 数据结构丶编程语句丶基础算法与数学的关系(笔记)<aside class="dates">2020-09-15</aside></a></li><li><a href="/archive/6iwpimvelxh/">数学篇 - 朴素贝叶斯(Naive Bayes)分类算法(笔记)<aside class="dates">2020-09-14</aside></a></li><li><a href="/archive/haz1cu03hf/">数学篇 - 概率之联合概率、条件概率、边缘概率和贝叶斯法则(笔记)<aside class="dates">2020-09-13</aside></a></li><li><a href="/archive/6mchh1x7mrv/">数学篇 - 概率之随机变量与分布(笔记)<aside class="dates">2020-09-12</aside></a></li><li><a href="/archive/5g1oligl91/">数学篇 - 树的深度优先搜索与广度优先搜索(笔记)<aside class="dates">2020-09-11</aside></a></li><li><a href="/archive/rakfaq9whbo/">数学篇 - 树的概念(笔记)<aside class="dates">2020-09-10</aside></a></li><li><a href="/archive/nfo3tlig7y/">数学篇 - 动态规划,编辑距离的计算(笔记)<aside class="dates">2020-09-09</aside></a></li><li><a href="/archive/yraotmb3ot/">数学篇 - 组合,解决赛程规划与自然语言处理(笔记)<aside class="dates">2020-09-08</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2020 Fan <a href="https://beian.miit.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://cdn.bootcdn.net/ajax/libs/justifiedGallery/3.6.1/js/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/js/main.js"></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
    if(location.host!=='alili.tech')return;
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script><script>var _mtac = {};
  (function() {
    if(location.host!=='alili.tech')return;
    var mta = document.createElement("script");
    mta.src = "//pingjs.qq.com/h5/stats.js?v2.0.4";
    mta.setAttribute("name", "MTAH5");
    mta.setAttribute("sid", "500643908");
    mta.setAttribute("cid", "500649335");
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(mta, s);
  })();</script></body></html>